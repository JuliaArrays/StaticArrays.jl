<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · StaticArrays.jl</title><meta name="title" content="API · StaticArrays.jl"/><meta property="og:title" content="API · StaticArrays.jl"/><meta property="twitter:title" content="API · StaticArrays.jl"/><meta name="description" content="Documentation for StaticArrays.jl."/><meta property="og:description" content="Documentation for StaticArrays.jl."/><meta property="twitter:description" content="Documentation for StaticArrays.jl."/><meta property="og:url" content="https://JuliaArrays.github.io/StaticArrays.jl/stable/api/"/><meta property="twitter:url" content="https://JuliaArrays.github.io/StaticArrays.jl/stable/api/"/><link rel="canonical" href="https://JuliaArrays.github.io/StaticArrays.jl/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StaticArrays.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Guide"><span>Guide</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaArrays/StaticArrays.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h2><h3 id="SVector"><a class="docs-heading-anchor" href="#SVector"><code>SVector</code></a><a id="SVector-1"></a><a class="docs-heading-anchor-permalink" href="#SVector" title="Permalink"></a></h3><p>The simplest static array is the type <code>SVector{N,T}</code>, which provides an immutable vector of fixed length <code>N</code> and type <code>T</code>.</p><p><code>SVector</code> defines a series of convenience constructors, so you can just type e.g. <code>SVector(1,2,3)</code>. Alternatively there is an intelligent <code>@SVector</code> macro where you can use native Julia array literals syntax, comprehensions, and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions, such as <code>@SVector [1,2,3]</code>, <code>@SVector Float64[1,2,3]</code>, <code>@SVector [f(i) for i = 1:10]</code>, <code>@SVector zeros(3)</code>, <code>@SVector randn(Float32, 4)</code>, etc (Note: the range of a comprehension is evaluated at global scope by the macro, and must be made of combinations of literal values, functions, or global variables, but is not limited to just simple ranges. Extending this to (hopefully statically known by type-inference) local-scope variables is hoped for the future. The <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code>, <code>randn()</code>, and <code>randexp()</code> functions do not have this limitation.)</p><h3 id="SMatrix"><a class="docs-heading-anchor" href="#SMatrix"><code>SMatrix</code></a><a id="SMatrix-1"></a><a class="docs-heading-anchor-permalink" href="#SMatrix" title="Permalink"></a></h3><p>Statically sized <code>N×M</code> matrices are provided by <code>SMatrix{N,M,T,L}</code>.</p><p>Here <code>L</code> is the <code>length</code> of the matrix, such that <code>N × M = L</code>. However, convenience constructors are provided, so that <code>L</code>, <code>T</code> and even <code>M</code> are unnecessary. At minimum, you can type <code>SMatrix{2}(1,2,3,4)</code> to create a 2×2 matrix (the total number of elements must divide evenly into <code>N</code>). A convenience macro <code>@SMatrix [1 2; 3 4]</code> is provided (which also accepts comprehensions and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code>, <code>randn()</code>, and <code>randexp()</code> functions).</p><h3 id="SArray"><a class="docs-heading-anchor" href="#SArray"><code>SArray</code></a><a id="SArray-1"></a><a class="docs-heading-anchor-permalink" href="#SArray" title="Permalink"></a></h3><p>A container with arbitrarily many dimensions is defined as <code>struct SArray{Size,T,N,L} &lt;: StaticArray{Size,T,N}</code>, where <code>Size = Tuple{S1, S2, ...}</code> is a tuple of <code>Int</code>s. You can easily construct one with the <code>@SArray</code> macro, supporting all the features of <code>@SVector</code> and <code>@SMatrix</code> (but with arbitrary dimension).</p><p>The main reason <code>SVector</code> and <code>SMatrix</code> are defined is to make it easier to define the types without the extra tuple characters (compare <code>SVector{3}</code> to <code>SArray{Tuple{3}}</code>).</p><h3 id="Scalar"><a class="docs-heading-anchor" href="#Scalar"><code>Scalar</code></a><a id="Scalar-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar" title="Permalink"></a></h3><p>Sometimes you want to broadcast an operation, but not over one of your inputs. A classic example is attempting to displace a collection of vectors by the same vector. We can now do this with the <code>Scalar</code> type:</p><pre><code class="language-julia hljs">[[1,2,3], [4,5,6]] .+ Scalar([1,0,-1]) # [[2,2,2], [5,5,5]]</code></pre><p><code>Scalar</code> is simply an implementation of an immutable, 0-dimensional <code>StaticArray</code>.</p><h3 id="The-Size-trait"><a class="docs-heading-anchor" href="#The-Size-trait">The <code>Size</code> trait</a><a id="The-Size-trait-1"></a><a class="docs-heading-anchor-permalink" href="#The-Size-trait" title="Permalink"></a></h3><p>The size of a statically sized array is a static parameter associated with the type of the array. The <code>Size</code> trait is provided as an abstract representation of the dimensions of a static array. An array <code>sa::SA</code> of size <code>(dims...)</code> is associated with <code>Size{(dims...)}()</code>. The following are equivalent constructors:</p><pre><code class="language-julia hljs">Size{(dims...,)}()
Size(dims...)
Size(sa::StaticArray)
Size(SA) # SA &lt;: StaticArray</code></pre><p>This is extremely useful for (a) performing dispatch depending on the size of an array, and (b) passing array dimensions that the compiler can reason about.</p><p>An example of size-based dispatch for the determinant of a matrix would be:</p><pre><code class="language-julia hljs">det(x::StaticMatrix) = _det(Size(x), x)
_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]
_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]
# and other definitions as necessary</code></pre><p>Examples of using <code>Size</code> as a compile-time constant include</p><pre><code class="language-julia hljs">reshape(svector, Size(2,2))  # Convert SVector{4} to SMatrix{2,2}
SizedMatrix{3,3}(rand(3,3))  # Construct a random 3×3 SizedArray (see below)</code></pre><h3 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h3><p>Statically sized indexing can be realized by indexing each dimension by a scalar, a <code>StaticVector</code> or <code>:</code>. Indexing in this way will result a statically sized array (even if the input was dynamically sized, in the case of <code>StaticVector</code> indices) of the closest type (as defined by <code>similar_type</code>).</p><p>Conversely, indexing a statically sized array with a dynamically sized index (such as a <code>Vector{Integer}</code> or <code>UnitRange{Integer}</code>) will result in a standard (dynamically sized) <code>Array</code>.</p><h3 id="similar_type()"><a class="docs-heading-anchor" href="#similar_type()"><code>similar_type()</code></a><a id="similar_type()-1"></a><a class="docs-heading-anchor-permalink" href="#similar_type()" title="Permalink"></a></h3><p>Since immutable arrays need to be constructed &quot;all-at-once&quot;, we need a way of obtaining an appropriate constructor if the element type or dimensions of the output array differs from the input. To this end, <code>similar_type</code> is introduced, behaving just like <code>similar</code>, except that it returns a type. Relevant methods are:</p><pre><code class="language-julia hljs">similar_type(::Type{A}) where {A &lt;: StaticArray} # defaults to A
similar_type(::Type{A}, ::Type{ElType}) where {A &lt;: StaticArray, ElType} # Change element type
similar_type(::Type{A}, size::Size) where {A &lt;: AbstractArray} # Change size
similar_type(::Type{A}, ::Type{ElType}, size::Size) where {A &lt;: AbstractArray, ElType} # Change both</code></pre><p>These setting will affect everything, from indexing, to matrix multiplication and <code>broadcast</code>. Users wanting introduce a new array type should <em>only</em> overload the last method in the above.</p><p>Use of <code>similar</code> will fall back to a mutable container, such as a <code>MVector</code> (see below), and it requires use of the <code>Size</code> trait if you wish to set a new static size (or else a dynamically sized <code>Array</code> will be generated when specifying the size as plain integers).</p><h3 id="Collecting-directly-into-static-arrays"><a class="docs-heading-anchor" href="#Collecting-directly-into-static-arrays">Collecting directly into static arrays</a><a id="Collecting-directly-into-static-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-directly-into-static-arrays" title="Permalink"></a></h3><p>You can collect <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration">iterators</a> into static arrays directly with <a href="#StaticArrays.sacollect"><code>StaticArrays.sacollect</code></a>. The size needs to be specified, but the element type is optional.</p><h3 id="Mutable-arrays:-MVector,-MMatrix-and-MArray"><a class="docs-heading-anchor" href="#Mutable-arrays:-MVector,-MMatrix-and-MArray">Mutable arrays: <code>MVector</code>, <code>MMatrix</code> and <code>MArray</code></a><a id="Mutable-arrays:-MVector,-MMatrix-and-MArray-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-arrays:-MVector,-MMatrix-and-MArray" title="Permalink"></a></h3><p>These statically sized arrays are identical to the above, but are defined as <code>mutable struct</code>s, instead of immutable <code>struct</code>s. Because they are mutable, they allow <code>setindex!</code> to be defined (achieved through pointer manipulation, into a tuple).</p><p>As a consequence of Julia&#39;s internal implementation, these mutable containers live on the heap, not the stack. Their memory must be allocated and tracked by the garbage collector. Nevertheless, there is opportunity for speed improvements relative to <code>Base.Array</code> because (a) there may be one less pointer indirection, (b) their (typically small) static size allows for additional loop unrolling and inlining, and consequentially (c) their mutating methods like <code>map!</code> are extremely fast. Benchmarking shows that operations such as addition and matrix multiplication are faster for <code>MMatrix</code> than <code>Matrix</code>, at least for sizes up to 14 × 14, though keep in mind that optimal speed will be obtained by using mutating functions (like <code>map!</code> or <code>mul!</code>) where possible, rather than reallocating new memory.</p><p>Mutable static arrays also happen to be very useful containers that can be constructed on the heap (with the ability to use <code>setindex!</code>, etc), and later copied as e.g. an immutable <code>SVector</code> to the stack for use, or into e.g. an <code>Array{SVector}</code> for storage.</p><p>Convenience macros <code>@MVector</code>, <code>@MMatrix</code> and <code>@MArray</code> are provided.</p><h3 id="SizedArray:-a-decorate-size-wrapper-for-Array"><a class="docs-heading-anchor" href="#SizedArray:-a-decorate-size-wrapper-for-Array"><code>SizedArray</code>: a decorate size wrapper for <code>Array</code></a><a id="SizedArray:-a-decorate-size-wrapper-for-Array-1"></a><a class="docs-heading-anchor-permalink" href="#SizedArray:-a-decorate-size-wrapper-for-Array" title="Permalink"></a></h3><p>Another convenient mutable type is the <code>SizedArray</code>, which is just a wrapper-type about a standard Julia <code>Array</code> which declares its known size. For example, if we knew that <code>a</code> was a 2×2 <code>Matrix</code>, then we can type <code>sa = SizedArray{Tuple{2,2}}(a)</code> to construct a new object which knows the type (the size will be verified automatically). For one and two dimensions, a more convenient syntax for obtaining a <code>SizedArray</code> is by using the <code>SizedMatrix</code> and <code>SizedVector</code> aliases, e.g. <code>sa = SizedMatrix{2,2}(a)</code>.</p><p>Then, methods on <code>sa</code> will use the specialized code provided by the <em>StaticArrays</em> package, which in many cases will be much, much faster. For example, calling <code>eigen(sa)</code> will be significantly faster than <code>eigen(a)</code> since it will perform a specialized 2×2 matrix diagonalization rather than a general algorithm provided by Julia and <em>LAPACK</em>.</p><p>In some cases it will make more sense to use a <code>SizedArray</code>, and in other cases an <code>MArray</code> might be preferable.</p><h3 id="FieldVector"><a class="docs-heading-anchor" href="#FieldVector"><code>FieldVector</code></a><a id="FieldVector-1"></a><a class="docs-heading-anchor-permalink" href="#FieldVector" title="Permalink"></a></h3><p>Sometimes it is useful to give your own struct types the properties of a vector. <em>StaticArrays</em> can take care of this for you by allowing you to inherit from <code>FieldVector{N, T}</code>. For example, consider:</p><pre><code class="language-julia hljs">struct Point3D &lt;: FieldVector{3, Float64}
    x::Float64
    y::Float64
    z::Float64
end</code></pre><p>With this type, users can easily access fields to <code>p = Point3D(x,y,z)</code> using <code>p.x</code>, <code>p.y</code> or <code>p.z</code>, or alternatively via <code>p[1]</code>, <code>p[2]</code>, or <code>p[3]</code>. You may even permute the coordinates with <code>p[SVector(3,2,1)]</code>). Furthermore, <code>Point3D</code> is a complete <code>AbstractVector</code> implementation where you can add, subtract or scale vectors, multiply them by matrices, etc.</p><p><em>Note</em>: the three components of an ordinary <code>v::SVector{3}</code> can also be accessed as <code>v.x</code>, <code>v.y</code>, and <code>v.z</code>, so there is no need for a <code>FieldVector</code> to use this convention.</p><p>It is also worth noting that <code>FieldVector</code>s may be mutable or immutable, and that <code>setindex!</code> is defined for use on mutable types. For immutable containers, you may want to define a method for <code>similar_type</code> so that operations leave the type constant (otherwise they may fall back to <code>SVector</code>). For mutable containers, you may want to define a default constructor (no inputs) and an appropriate method for <code>similar</code>,</p><h3 id="Implementing-your-own-types"><a class="docs-heading-anchor" href="#Implementing-your-own-types">Implementing your own types</a><a id="Implementing-your-own-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-your-own-types" title="Permalink"></a></h3><p>You can easily create your own <code>StaticArray</code> type, by defining linear <code>getindex</code> (and optionally <code>setindex!</code> for mutable types –- see <code>setindex!(::MArray, val, i)</code> in <em>MArray.jl</em> for an example of how to achieve this through pointer manipulation). Your type should define a constructor that takes a tuple of the data (and mutable containers may want to define a default constructor).</p><p>Other useful functions to overload may be <code>similar_type</code> (and <code>similar</code> for mutable containers).</p><h3 id="Conversions-from-Array"><a class="docs-heading-anchor" href="#Conversions-from-Array">Conversions from <code>Array</code></a><a id="Conversions-from-Array-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions-from-Array" title="Permalink"></a></h3><p>In order to convert from a dynamically sized <code>AbstractArray</code> to one of the statically sized array types, you must specify the size explicitly.  For example,</p><pre><code class="language-julia hljs">v = [1,2]

m = [1 2;
     3 4]

# ... a lot of intervening code

sv = SVector{2}(v)
sm = SMatrix{2,2}(m)
sa = SArray{Tuple{2,2}}(m)

sized_v = SizedVector{2}(v)
sized_m = SizedMatrix{2,2}(m)</code></pre><p>We have avoided adding <code>SVector(v::AbstractVector)</code> as a valid constructor to help users avoid the type instability (and potential performance disaster, if used without care) of this innocuous looking expression.</p><h3 id="Arrays-of-static-arrays"><a class="docs-heading-anchor" href="#Arrays-of-static-arrays">Arrays of static arrays</a><a id="Arrays-of-static-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-of-static-arrays" title="Permalink"></a></h3><p>Storing a large number of static arrays is convenient as an array of static arrays. For example, a collection of positions (3D coordinates –- <code>SVector{3,Float64}</code>) could be represented as a <code>Vector{SVector{3,Float64}}</code>.</p><p>Another common way of storing the same data is as a 3×<code>N</code> <code>Matrix{Float64}</code>. Rather conveniently, such types have <em>exactly</em> the same binary layout in memory, and therefore we can use <code>reinterpret</code> to convert between the two formats</p><pre><code class="language-julia hljs">function svectors(x::Matrix{T}, ::Val{N}) where {T,N}
    size(x,1) == N || error(&quot;sizes mismatch&quot;)
    isbitstype(T) || error(&quot;use for bitstypes only&quot;)
    reinterpret(SVector{N,T}, vec(x))
end</code></pre><p>Such a conversion does not copy the data, rather it refers to the <em>same</em> memory. Arguably, a <code>Vector</code> of <code>SVector</code>s is often preferable to a <code>Matrix</code> because it provides a better abstraction of the objects contained in the array and it allows the fast <em>StaticArrays</em> methods to act on elements.</p><p>However, the resulting object is a Base.ReinterpretArray, not an Array, which carries some runtime penalty on every single access. If you can afford the memory for a copy and can live with the non-shared mutation semantics, then it is better to pull a copy by e.g.</p><pre><code class="language-julia hljs">function svectorscopy(x::Matrix{T}, ::Val{N}) where {T,N}
    size(x,1) == N || error(&quot;sizes mismatch&quot;)
    isbitstype(T) || error(&quot;use for bitstypes only&quot;)
    copy(reinterpret(SVector{N,T}, vec(x)))
end</code></pre><p>For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = reshape(collect(1:6), (2,3))</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Int64}:
 1  3  5
 2  4  6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; svectors(M, Val{2}())</code><code class="nohighlight hljs ansi" style="display:block;">3-element reinterpret(SVector{2, Int64}, ::Vector{Int64}):
 [1, 2]
 [3, 4]
 [5, 6]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; svectorscopy(M, Val{2}())</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{SVector{2, Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]</code></pre><h3 id="Working-with-mutable-and-immutable-arrays"><a class="docs-heading-anchor" href="#Working-with-mutable-and-immutable-arrays">Working with mutable and immutable arrays</a><a id="Working-with-mutable-and-immutable-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-mutable-and-immutable-arrays" title="Permalink"></a></h3><p>Generally, it is performant to rebind an <em>immutable</em> array, such as</p><pre><code class="language-julia hljs">function average_position(positions::Vector{SVector{3,Float64}})
    x = zeros(SVector{3,Float64})
    for pos ∈ positions
        x = x + pos
    end
    return x / length(positions)
end</code></pre><p>so long as the <code>Type</code> of the rebound variable (<code>x</code>, above) does not change.</p><p>On the other hand, the above code for mutable containers like <code>Array</code>, <code>MArray</code> or <code>SizedArray</code> is <em>not</em> very efficient. Mutable containers must be <em>allocated</em> and later <em>garbage collected</em>, and for small, fixed-size arrays this can be a leading contribution to the cost. In the above code, a new array will be instantiated and allocated on each iteration of the loop. In order to avoid unnecessary allocations, it is best to allocate an array only once and apply mutating functions to it:</p><pre><code class="language-julia hljs">function average_position(positions::Vector{SVector{3,Float64}})
    x = zeros(MVector{3,Float64})
    for pos ∈ positions
        x .+= pos
    end
    x ./= length(positions)
    return x
end</code></pre><p>The functions <code>setindex</code>, <code>push</code>, <code>pop</code>, <code>pushfirst</code>, <code>popfirst</code>, <code>insert</code> and <code>deleteat</code> are provided for performing certain specific operations on static arrays, in analogy with the standard functions <code>setindex!</code>, <code>push!</code>, <code>pop!</code>, etc. (Note that if the size of the static array changes, the type of the output will differ from the input.)</p><p>When building static arrays iteratively, it is usually efficient to build up an <code>MArray</code> first and then convert. The allocation will be elided by recent Julia compilers, resulting in very efficient code:</p><pre><code class="language-julia hljs">function standard_basis_vector(T, ::Val{I}, ::Val{N}) where {I,N}
    v = zero(MVector{N,T})
    v[I] = one(T)
    SVector(v)
end</code></pre><h3 id="SIMD-optimizations"><a class="docs-heading-anchor" href="#SIMD-optimizations">SIMD optimizations</a><a id="SIMD-optimizations-1"></a><a class="docs-heading-anchor-permalink" href="#SIMD-optimizations" title="Permalink"></a></h3><p>It seems Julia and LLVM are smart enough to use processor vectorization extensions like SSE and AVX - however they are currently partially disabled by default. Run Julia with <code>julia -O</code> or <code>julia -O3</code> to enable these optimizations, and many of your (immutable) <code>StaticArray</code> methods <em>should</em> become significantly faster!</p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><ul><li><a href="#StaticArrays.Args"><code>StaticArrays.Args</code></a></li><li><a href="#StaticArrays.SA"><code>StaticArrays.SA</code></a></li><li><a href="#StaticArrays.SHermitianCompact"><code>StaticArrays.SHermitianCompact</code></a></li><li><a href="#StaticArrays.SOneTo"><code>StaticArrays.SOneTo</code></a></li><li><a href="#StaticArrays.Scalar"><code>StaticArrays.Scalar</code></a></li><li><a href="#StaticArrays.StaticMatMulLike"><code>StaticArrays.StaticMatMulLike</code></a></li><li><a href="#StaticArrays.TSize"><code>StaticArrays.TSize</code></a></li><li><a href="#StaticArrays._InitialValue"><code>StaticArrays._InitialValue</code></a></li><li><a href="#StaticArraysCore.Dynamic"><code>StaticArraysCore.Dynamic</code></a></li><li><a href="#StaticArraysCore.FieldArray"><code>StaticArraysCore.FieldArray</code></a></li><li><a href="#StaticArraysCore.FieldMatrix"><code>StaticArraysCore.FieldMatrix</code></a></li><li><a href="#StaticArraysCore.FieldVector"><code>StaticArraysCore.FieldVector</code></a></li><li><a href="#StaticArraysCore.MArray"><code>StaticArraysCore.MArray</code></a></li><li><a href="#StaticArraysCore.MMatrix"><code>StaticArraysCore.MMatrix</code></a></li><li><a href="#StaticArraysCore.MVector"><code>StaticArraysCore.MVector</code></a></li><li><a href="#StaticArraysCore.SArray"><code>StaticArraysCore.SArray</code></a></li><li><a href="#StaticArraysCore.SMatrix"><code>StaticArraysCore.SMatrix</code></a></li><li><a href="#StaticArraysCore.SVector"><code>StaticArraysCore.SVector</code></a></li><li><a href="#StaticArraysCore.Size"><code>StaticArraysCore.Size</code></a></li><li><a href="#StaticArraysCore.SizedArray"><code>StaticArraysCore.SizedArray</code></a></li><li><a href="#StaticArraysCore.SizedMatrix"><code>StaticArraysCore.SizedMatrix</code></a></li><li><a href="#StaticArraysCore.SizedVector"><code>StaticArraysCore.SizedVector</code></a></li><li><a href="#StaticArraysCore.StaticArray"><code>StaticArraysCore.StaticArray</code></a></li><li><a href="#Base.setindex-Tuple{StaticArray, Any, Int64}"><code>Base.setindex</code></a></li><li><a href="#Base.similar-Tuple{SA} where SA&lt;:StaticArray"><code>Base.similar</code></a></li><li><a href="#LinearAlgebra.qr-Tuple{StaticArray{Tuple{N, M}, T, 2} where {N, M, T}}"><code>LinearAlgebra.qr</code></a></li><li><a href="#StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any, Size, Tuple{ET, Vararg{ET, L}}}} where {L, ET}"><code>StaticArrays._construct_similar</code></a></li><li><a href="#StaticArrays._lind-Union{Tuple{tA}, Tuple{sa}, Tuple{Symbol, Type{StaticArrays.TSize{sa, tA}}, Int64, Int64}} where {sa, tA}"><code>StaticArrays._lind</code></a></li><li><a href="#StaticArrays._muladd_expr-Tuple{Array{Expr, N} where N, Array{Expr, N} where N, Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:StaticArrays.AlphaBeta}"><code>StaticArrays._muladd_expr</code></a></li><li><a href="#StaticArrays._size-Tuple{Any}"><code>StaticArrays._size</code></a></li><li><a href="#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>StaticArrays.arithmetic_closure</code></a></li><li><a href="#StaticArrays.check_dims-Union{Tuple{sc}, Tuple{sb}, Tuple{sa}, Tuple{Size{sc}, Size{sa}, Size{sb}}} where {sa, sb, sc}"><code>StaticArrays.check_dims</code></a></li><li><a href="#StaticArrays.construct_type-Union{Tuple{SA}, Tuple{Type{SA}, Any}} where SA&lt;:StaticArray"><code>StaticArrays.construct_type</code></a></li><li><a href="#StaticArrays.deleteat-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}"><code>StaticArrays.deleteat</code></a></li><li><a href="#StaticArrays.dimmatch"><code>StaticArrays.dimmatch</code></a></li><li><a href="#StaticArrays.gen_by_access-Tuple{Any, Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:(StaticArray{Tuple{N, M}, T, 2} where {N, M, T}), Type}"><code>StaticArrays.gen_by_access</code></a></li><li><a href="#StaticArrays.gen_by_access"><code>StaticArrays.gen_by_access</code></a></li><li><a href="#StaticArrays.insert-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any, Any}"><code>StaticArrays.insert</code></a></li><li><a href="#StaticArrays.mul_result_structure-Tuple{Any, Any}"><code>StaticArrays.mul_result_structure</code></a></li><li><a href="#StaticArrays.multiplied_dimension-Tuple{Type{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(Union{LinearAlgebra.Adjoint{T, var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.Diagonal{T, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(StaticArray{Tuple{var&quot;#s13&quot;}, T, 1} where var&quot;#s13&quot;), LinearAlgebra.Hermitian{T, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(StaticArray{Tuple{var&quot;#s10&quot;, var&quot;#s11&quot;}, T, 2} where {var&quot;#s10&quot;, var&quot;#s11&quot;}), LinearAlgebra.LowerTriangular{T, var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(StaticArray{Tuple{var&quot;#s18&quot;, var&quot;#s19&quot;}, T, 2} where {var&quot;#s18&quot;, var&quot;#s19&quot;}), LinearAlgebra.Symmetric{T, var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(StaticArray{Tuple{var&quot;#s7&quot;, var&quot;#s8&quot;}, T, 2} where {var&quot;#s7&quot;, var&quot;#s8&quot;}), LinearAlgebra.Transpose{T, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.UnitLowerTriangular{T, var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(StaticArray{Tuple{var&quot;#s24&quot;, var&quot;#s25&quot;}, T, 2} where {var&quot;#s24&quot;, var&quot;#s25&quot;}), LinearAlgebra.UnitUpperTriangular{T, var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(StaticArray{Tuple{var&quot;#s21&quot;, var&quot;#s22&quot;}, T, 2} where {var&quot;#s21&quot;, var&quot;#s22&quot;}), LinearAlgebra.UpperTriangular{T, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(StaticArray{Tuple{var&quot;#s15&quot;, var&quot;#s16&quot;}, T, 2} where {var&quot;#s15&quot;, var&quot;#s16&quot;}), StaticArray{Tuple{var&quot;#s25&quot;}, T, 1} where var&quot;#s25&quot;, StaticArray{Tuple{var&quot;#s1&quot;, var&quot;#s3&quot;}, T, 2} where {var&quot;#s1&quot;, var&quot;#s3&quot;}} where T), Type{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Union{LinearAlgebra.Adjoint{T, var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.Diagonal{T, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(StaticArray{Tuple{var&quot;#s13&quot;}, T, 1} where var&quot;#s13&quot;), LinearAlgebra.Hermitian{T, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(StaticArray{Tuple{var&quot;#s10&quot;, var&quot;#s11&quot;}, T, 2} where {var&quot;#s10&quot;, var&quot;#s11&quot;}), LinearAlgebra.LowerTriangular{T, var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(StaticArray{Tuple{var&quot;#s18&quot;, var&quot;#s19&quot;}, T, 2} where {var&quot;#s18&quot;, var&quot;#s19&quot;}), LinearAlgebra.Symmetric{T, var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(StaticArray{Tuple{var&quot;#s7&quot;, var&quot;#s8&quot;}, T, 2} where {var&quot;#s7&quot;, var&quot;#s8&quot;}), LinearAlgebra.Transpose{T, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.UnitLowerTriangular{T, var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(StaticArray{Tuple{var&quot;#s24&quot;, var&quot;#s25&quot;}, T, 2} where {var&quot;#s24&quot;, var&quot;#s25&quot;}), LinearAlgebra.UnitUpperTriangular{T, var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(StaticArray{Tuple{var&quot;#s21&quot;, var&quot;#s22&quot;}, T, 2} where {var&quot;#s21&quot;, var&quot;#s22&quot;}), LinearAlgebra.UpperTriangular{T, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(StaticArray{Tuple{var&quot;#s15&quot;, var&quot;#s16&quot;}, T, 2} where {var&quot;#s15&quot;, var&quot;#s16&quot;}), StaticArray{Tuple{var&quot;#s25&quot;}, T, 1} where var&quot;#s25&quot;, StaticArray{Tuple{var&quot;#s1&quot;, var&quot;#s3&quot;}, T, 2} where {var&quot;#s1&quot;, var&quot;#s3&quot;}} where T)}"><code>StaticArrays.multiplied_dimension</code></a></li><li><a href="#StaticArrays.pop-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}"><code>StaticArrays.pop</code></a></li><li><a href="#StaticArrays.popfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}"><code>StaticArrays.popfirst</code></a></li><li><a href="#StaticArrays.push-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}"><code>StaticArrays.push</code></a></li><li><a href="#StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}"><code>StaticArrays.pushfirst</code></a></li><li><a href="#StaticArrays.sacollect"><code>StaticArrays.sacollect</code></a></li><li><a href="#StaticArrays.same_size-Tuple"><code>StaticArrays.same_size</code></a></li><li><a href="#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S}, StaticArray}} where S"><code>StaticArrays.sizematch</code></a></li><li><a href="#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1}, Size{S2}}} where {S1, S2}"><code>StaticArrays.sizematch</code></a></li><li><a href="#StaticArrays.uplo_access-NTuple{5, Any}"><code>StaticArrays.uplo_access</code></a></li><li><a href="#StaticArraysCore.similar_type"><code>StaticArraysCore.similar_type</code></a></li><li><a href="#StaticArraysCore.size_to_tuple-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Tuple"><code>StaticArraysCore.size_to_tuple</code></a></li><li><a href="#StaticArrays.@MArray-Tuple{Any}"><code>StaticArrays.@MArray</code></a></li><li><a href="#StaticArrays.@MMatrix-Tuple{Any}"><code>StaticArrays.@MMatrix</code></a></li><li><a href="#StaticArrays.@MVector-Tuple{Any}"><code>StaticArrays.@MVector</code></a></li><li><a href="#StaticArrays.@SArray-Tuple{Any}"><code>StaticArrays.@SArray</code></a></li><li><a href="#StaticArrays.@SMatrix-Tuple{Any}"><code>StaticArrays.@SMatrix</code></a></li><li><a href="#StaticArrays.@SVector-Tuple{Any}"><code>StaticArrays.@SVector</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.StaticMatMulLike" href="#StaticArrays.StaticMatMulLike"><code>StaticArrays.StaticMatMulLike</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticMatMulLike</code></pre><p>Static wrappers used for multiplication dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.Args" href="#StaticArrays.Args"><code>StaticArrays.Args</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Args</code></pre><p>A help wrapper to distinguish <code>SA(x...)</code> and <code>SA((x...,))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/convert.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.SA" href="#StaticArrays.SA"><code>StaticArrays.SA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SA[ elements ]
SA{T}[ elements ]</code></pre><p>Create <code>SArray</code> literals using array construction syntax. The element type is inferred by promoting <code>elements</code> to a common type or set to <code>T</code> when <code>T</code> is provided explicitly.</p><p><strong>Examples:</strong></p><ul><li><code>SA[1.0, 2.0]</code> creates a length-2 <code>SVector</code> of <code>Float64</code> elements.</li><li><code>SA[1 2; 3 4]</code> creates a 2×2 <code>SMatrix</code> of <code>Int</code>s.</li><li><code>SA[1 2]</code> creates a 1×2 <code>SMatrix</code> of <code>Int</code>s.</li><li><code>SA{Float32}[1, 2]</code> creates a length-2 <code>SVector</code> of <code>Float32</code> elements.</li></ul><p>A couple of helpful type aliases are also provided:</p><ul><li><code>SA_F64[1, 2]</code> creates a length-2 <code>SVector</code> of <code>Float64</code> elements</li><li><code>SA_F32[1, 2]</code> creates a length-2 <code>SVector</code> of <code>Float32</code> elements</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/initializers.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.SHermitianCompact" href="#StaticArrays.SHermitianCompact"><code>StaticArrays.SHermitianCompact</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SHermitianCompact{N, T, L} &lt;: StaticMatrix{N, N, T}</code></pre><p>A <a href="#StaticArraysCore.StaticArray"><code>StaticArray</code></a> subtype that can represent a Hermitian matrix. Unlike <code>LinearAlgebra.Hermitian</code>, <code>SHermitianCompact</code> stores only the lower triangle of the matrix (as an <code>SVector</code>), and the diagonal may not be real. The lower triangle is stored in column-major order and the superdiagonal entries are  <code>adjoint</code> to the transposed subdiagonal entries. The diagonal is returned as-is. For example, for an <code>SHermitianCompact{3}</code>, the indices of the stored elements can be visualized as follows:</p><pre><code class="nohighlight hljs">┌ 1 ⋅ ⋅ ┐
| 2 4 ⋅ |
└ 3 5 6 ┘</code></pre><p>Type parameters:</p><ul><li><code>N</code>: matrix dimension;</li><li><code>T</code>: element type for lower triangle;</li><li><code>L</code>: length of the <code>SVector</code> storing the lower triangular elements.</li></ul><p>Note that <code>L</code> is always the <code>N</code>th <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular number</a>.</p><p>An <code>SHermitianCompact</code> may be constructed either:</p><ul><li>from an <code>AbstractVector</code> containing the lower triangular elements; or</li><li>from a <code>Tuple</code> containing both upper and lower triangular elements in column major order; or</li><li>from another <code>StaticMatrix</code>.</li></ul><p>For the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.</p><p>When its element type is real, then a <code>SHermitianCompact</code> is both Hermitian and symmetric. Otherwise, to ensure that a <code>SHermitianCompact</code> matrix, <code>a</code>, is Hermitian according to <code>LinearAlgebra.ishermitian</code>, take an average with its adjoint, i.e. <code>(a+a&#39;)/2</code>, or take a Hermitian view of the data with <code>LinearAlgebra.Hermitian(a)</code>. However, the latter case is not specialized to use the compact storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/SHermitianCompact.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.SOneTo" href="#StaticArrays.SOneTo"><code>StaticArrays.SOneTo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SOneTo(n)</code></pre><p>Return a statically-sized <code>AbstractUnitRange</code> starting at <code>1</code>, functioning as the <code>axes</code> of a <code>StaticArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/SOneTo.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.Scalar" href="#StaticArrays.Scalar"><code>StaticArrays.Scalar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Scalar{T}(x::T)</code></pre><p>Construct a statically-sized 0-dimensional array that contains a single element, <code>x</code>. This type is particularly useful for influencing broadcasting operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/Scalar.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.TSize" href="#StaticArrays.TSize"><code>StaticArrays.TSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TSize{S,T}</code></pre><p>Size that stores whether a Matrix is a Transpose. Useful when selecting multiplication methods, and avoiding allocations when dealing with the <code>Transpose</code> type by passing around the original matrix. Should pair with <code>parent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays._InitialValue" href="#StaticArrays._InitialValue"><code>StaticArrays._InitialValue</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_InitialValue</code></pre><p>A singleton type for representing &quot;universal&quot; initial value (identity element).</p><p>The idea is that, given <code>op</code> for <code>mapfoldl</code>, virtually, we define an &quot;extended&quot; version of it by</p><pre><code class="language-julia hljs">op′(::_InitialValue, x) = x
op′(acc, x) = op(acc, x)</code></pre><p>This is just a conceptually useful model to have in mind and we don&#39;t actually define <code>op′</code> here  (yet?).  But see <code>Base.BottomRF</code> for how it might work in action.</p><p>(It is related to that you can always turn a semigroup without an identity into a monoid by &quot;adjoining&quot; an element that acts as the identity.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/mapreduce.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex-Tuple{StaticArray, Any, Int64}" href="#Base.setindex-Tuple{StaticArray, Any, Int64}"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setindex(vec::StaticArray, x, index::Int)</code></pre><p>Return a new array with the item at <code>index</code> replaced by <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setindex(@SVector[1,2,3], 4, 2)
3-element SVector{3, Int64} with indices SOneTo(3):
 1
 4
 3

julia&gt; setindex(@SMatrix[2 4; 6 8], 1, 2)
2×2 SMatrix{2, 2, Int64, 4} with indices SOneTo(2)×SOneTo(2):
 2  4
 1  8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L166-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Tuple{SA} where SA&lt;:StaticArray" href="#Base.similar-Tuple{SA} where SA&lt;:StaticArray"><code>Base.similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar(static_array)
similar(static_array, T)
similar(array, ::Size)
similar(array, T, ::Size)</code></pre><p>Constructs and returns a mutable but statically-sized array (i.e. a <code>StaticArray</code>). If the input <code>array</code> is not a <code>StaticArray</code>, then the <code>Size</code> is required to determine the output size (or else a dynamically sized array will be returned).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/abstractarray.jl#L106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.qr-Tuple{StaticArray{Tuple{N, M}, T, 2} where {N, M, T}}" href="#LinearAlgebra.qr-Tuple{StaticArray{Tuple{N, M}, T, 2} where {N, M, T}}"><code>LinearAlgebra.qr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr(A::StaticMatrix,
   pivot::Union{Val{true}, Val{false}, LinearAlgebra.PivotingStrategy} = Val(false))</code></pre><p>Compute the QR factorization of <code>A</code>. The factors can be obtained by iteration:</p><pre><code class="language-julia-repl hljs">julia&gt; A = @SMatrix rand(3,4);

julia&gt; Q, R = qr(A);

julia&gt; Q * R ≈ A
true</code></pre><p>or by using <code>getfield</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; F = qr(A);

julia&gt; F.Q * F.R ≈ A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/qr.jl#L35-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any, Size, Tuple{ET, Vararg{ET, L}}}} where {L, ET}" href="#StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any, Size, Tuple{ET, Vararg{ET, L}}}} where {L, ET}"><code>StaticArrays._construct_similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_construct_similar(a, ::Size, elements::NTuple)</code></pre><p>Construct a static array of similar type to <code>a</code> with the given <code>elements</code>.</p><p>When <code>a</code> is an instance or a concrete type the element type <code>eltype(a)</code> is used. However, when <code>a</code> is a <code>UnionAll</code> type such as <code>SMatrix{2,2}</code>, the promoted type of <code>elements</code> is used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/abstractarray.jl#L90-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays._lind-Union{Tuple{tA}, Tuple{sa}, Tuple{Symbol, Type{StaticArrays.TSize{sa, tA}}, Int64, Int64}} where {sa, tA}" href="#StaticArrays._lind-Union{Tuple{tA}, Tuple{sa}, Tuple{Symbol, Type{StaticArrays.TSize{sa, tA}}, Int64, Int64}} where {sa, tA}"><code>StaticArrays._lind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_lind(var, A, k, j)</code></pre><p>Obtain an expression for the linear index of <code>var[k,j]</code>, taking transposes into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L394-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays._muladd_expr-Tuple{Array{Expr, N} where N, Array{Expr, N} where N, Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:StaticArrays.AlphaBeta}" href="#StaticArrays._muladd_expr-Tuple{Array{Expr, N} where N, Array{Expr, N} where N, Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:StaticArrays.AlphaBeta}"><code>StaticArrays._muladd_expr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_muladd_expr(lhs, rhs, coeffs)</code></pre><p>Combine left and right sides of an assignment expression, short-cutting <code>lhs = α * rhs + β * lhs</code>, element-wise. If <code>α = 1</code>, the multiplication by <code>α</code> is removed. If <code>β = 0</code>, the second <code>rhs</code> term is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L370-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays._size-Tuple{Any}" href="#StaticArrays._size-Tuple{Any}"><code>StaticArrays._size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_size(a)</code></pre><p>Return either the statically known <code>Size()</code> or runtime <code>size()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/traits.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>StaticArrays.arithmetic_closure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arithmetic_closure(T)</code></pre><p>Return the type which values of type <code>T</code> will promote to under a combination of the arithmetic operations <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import StaticArrays.arithmetic_closure

julia&gt; arithmetic_closure(Bool)
Float64

julia&gt; arithmetic_closure(Int32)
Float64

julia&gt; arithmetic_closure(BigFloat)
BigFloat

julia&gt; arithmetic_closure(BigInt)
BigFloat</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/arraymath.jl#L182-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.check_dims-Union{Tuple{sc}, Tuple{sb}, Tuple{sa}, Tuple{Size{sc}, Size{sa}, Size{sb}}} where {sa, sb, sc}" href="#StaticArrays.check_dims-Union{Tuple{sc}, Tuple{sb}, Tuple{sa}, Tuple{Size{sc}, Size{sa}, Size{sb}}} where {sa, sb, sc}"><code>StaticArrays.check_dims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_dims(sc, sa, sb)</code></pre><p>Validate the dimensions of a matrix multiplication, including matrix-vector products</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.construct_type-Union{Tuple{SA}, Tuple{Type{SA}, Any}} where SA&lt;:StaticArray" href="#StaticArrays.construct_type-Union{Tuple{SA}, Tuple{Type{SA}, Any}} where SA&lt;:StaticArray"><code>StaticArrays.construct_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SA′ = construct_type(::Type{SA}, x) where {SA&lt;:StaticArray}</code></pre><p>Pick a proper constructor <code>SA′</code> based on <code>x</code> if <code>SA(x)</code>/<code>SA(x...)</code> has no specific definition. The default returned <code>SA′</code> is <code>SA</code> itself for user defined <code>StaticArray</code>s. This differs from  <code>similar_type()</code> in that <code>SA′</code> should always be a subtype of <code>SA</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To distinguish <code>SA(x...)</code> and <code>SA(x::Tuple)</code>, the former calls  <code>construct_type(SA, StaticArrays.Args(x))</code> instead of <code>construct_type(SA, x)</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Please make sure <code>SA&#39;(x)</code> has a specific definition if the default behavior is overloaded.  Otherwise construction might fall into infinite recursion.</p></div></div><hr/><p>The adaption rules for official <code>StaticArray</code>s could be summarized as:</p><p><strong><code>SA &lt;: FieldArray</code>: <code>eltype</code> adaptable</strong></p><p><code>FieldArray</code>s are always static-sized. We only derive <code>SA′</code>&#39;s <code>eltype</code> using type promotion if needed.</p><p><strong><code>SA &lt;: Union{SArray, MArray, SHermitianCompact, SizedArray}</code>: <code>size</code>/<code>eltype</code> adaptable</strong></p><ul><li><p><code>SA(x::Tuple)</code></p><p>If <code>SA</code> is fully static-sized, then we first try to fill <code>SA</code> with <code>x</code>&#39;s elements. If failed and <code>length(SA) == 1</code>, then we try to fill <code>SA</code> with <code>x</code> itself.</p><p>If <code>SA</code> is not fully static-sized, then we always try to fill <code>SA</code> with <code>x</code>&#39;s elements, and the constructor&#39;s <code>Size</code> is derived based on:</p><ol><li>If <code>SA &lt;: StaticVector</code>, then we use <code>length(x)</code> as the output <code>Length</code></li><li>If <code>SA &lt;: StaticMatrix{M}</code>, then we use <code>(M, N)</code> (<code>N = length(x) ÷ M</code>) as the output <code>Size</code></li><li>If <code>SA &lt;: StaticMatrix{M,M} where M</code>, then we use <code>(N, N)</code> (<code>N = sqrt(length(x)</code>) as the output <code>Size</code>.</li></ol></li><li><p><code>SA(x...)</code></p><p>Similar to <code>Tuple</code>, but we never fill <code>SA</code> with <code>x</code> itself.</p></li><li><p><code>SA(x::StaticArray)</code></p><p>We treat <code>x</code> as <code>Tuple</code> whenever possible. If failed, then try to inherit <code>x</code>&#39;s <code>Size</code>.</p></li><li><p><code>SA(x::AbstractArray)</code></p><p><code>x</code> is used to provide eltype. Thus <code>SA</code> must be static sized.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/convert.jl#L39-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.deleteat-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}" href="#StaticArrays.deleteat-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}"><code>StaticArrays.deleteat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deleteat(vec::StaticVector, index::Integer)</code></pre><p>Return a new vector with the item at the given <code>index</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deleteat(@SVector[6, 5, 4, 3, 2, 1], 2)
5-element SVector{5, Int64} with indices SOneTo(5):
 6
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.dimmatch" href="#StaticArrays.dimmatch"><code>StaticArrays.dimmatch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimmatch(x::StaticDimension, y::StaticDimension)</code></pre><p>Return whether dimensions <code>x</code> and <code>y</code> match at compile time, that is:</p><ul><li>if <code>x</code> and <code>y</code> are both <code>Int</code>s, check that they are equal</li><li>if <code>x</code> or <code>y</code> are <code>Dynamic()</code>, return true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/traits.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.gen_by_access" href="#StaticArrays.gen_by_access"><code>StaticArrays.gen_by_access</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_by_access(expr_gen, a::Type{&lt;:AbstractArray}, asym = :wrapped_a)</code></pre><p>Statically generate outer code for fully unrolled multiplication loops. Returned code does wrapper-specific tests (for example if a symmetric matrix view is <code>U</code> or <code>L</code>) and the body of the if expression is then generated by function <code>expr_gen</code>. The function <code>expr_gen</code> receives access pattern description symbol as its argument and this symbol is then consumed by uplo_access to generate the right code for matrix element access.</p><p>The name of the matrix to test is indicated by <code>asym</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L33-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.gen_by_access-Tuple{Any, Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:(StaticArray{Tuple{N, M}, T, 2} where {N, M, T}), Type}" href="#StaticArrays.gen_by_access-Tuple{Any, Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:(StaticArray{Tuple{N, M}, T, 2} where {N, M, T}), Type}"><code>StaticArrays.gen_by_access</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_by_access(expr_gen, a::Type{&lt;:AbstractArray}, b::Type{&lt;:AbstractArray})</code></pre><p>Similar to <code>gen_by_access</code> with only one type argument. The difference is that tests for both arrays of type <code>a</code> and <code>b</code> are generated and <code>expr_gen</code> receives two access arguments, first for matrix <code>a</code> and the second for matrix <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.insert-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any, Any}" href="#StaticArrays.insert-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any, Any}"><code>StaticArrays.insert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert(vec::StaticVector, index::Integer, item)</code></pre><p>Return a new vector with <code>item</code> inserted into <code>vec</code> at the given <code>index</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; insert(@SVector[6, 5, 4, 2, 1], 4, 3)
6-element SVector{6, Int64} with indices SOneTo(6):
 6
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.mul_result_structure-Tuple{Any, Any}" href="#StaticArrays.mul_result_structure-Tuple{Any, Any}"><code>StaticArrays.mul_result_structure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mul_result_structure(a::Type, b::Type)</code></pre><p>Get a structure wrapper that should be applied to the result of multiplication of matrices of given types (<code>a*b</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.multiplied_dimension-Tuple{Type{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(Union{LinearAlgebra.Adjoint{T, var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.Diagonal{T, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(StaticArray{Tuple{var&quot;#s13&quot;}, T, 1} where var&quot;#s13&quot;), LinearAlgebra.Hermitian{T, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(StaticArray{Tuple{var&quot;#s10&quot;, var&quot;#s11&quot;}, T, 2} where {var&quot;#s10&quot;, var&quot;#s11&quot;}), LinearAlgebra.LowerTriangular{T, var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(StaticArray{Tuple{var&quot;#s18&quot;, var&quot;#s19&quot;}, T, 2} where {var&quot;#s18&quot;, var&quot;#s19&quot;}), LinearAlgebra.Symmetric{T, var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(StaticArray{Tuple{var&quot;#s7&quot;, var&quot;#s8&quot;}, T, 2} where {var&quot;#s7&quot;, var&quot;#s8&quot;}), LinearAlgebra.Transpose{T, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.UnitLowerTriangular{T, var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(StaticArray{Tuple{var&quot;#s24&quot;, var&quot;#s25&quot;}, T, 2} where {var&quot;#s24&quot;, var&quot;#s25&quot;}), LinearAlgebra.UnitUpperTriangular{T, var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(StaticArray{Tuple{var&quot;#s21&quot;, var&quot;#s22&quot;}, T, 2} where {var&quot;#s21&quot;, var&quot;#s22&quot;}), LinearAlgebra.UpperTriangular{T, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(StaticArray{Tuple{var&quot;#s15&quot;, var&quot;#s16&quot;}, T, 2} where {var&quot;#s15&quot;, var&quot;#s16&quot;}), StaticArray{Tuple{var&quot;#s25&quot;}, T, 1} where var&quot;#s25&quot;, StaticArray{Tuple{var&quot;#s1&quot;, var&quot;#s3&quot;}, T, 2} where {var&quot;#s1&quot;, var&quot;#s3&quot;}} where T), Type{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Union{LinearAlgebra.Adjoint{T, var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.Diagonal{T, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(StaticArray{Tuple{var&quot;#s13&quot;}, T, 1} where var&quot;#s13&quot;), LinearAlgebra.Hermitian{T, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(StaticArray{Tuple{var&quot;#s10&quot;, var&quot;#s11&quot;}, T, 2} where {var&quot;#s10&quot;, var&quot;#s11&quot;}), LinearAlgebra.LowerTriangular{T, var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(StaticArray{Tuple{var&quot;#s18&quot;, var&quot;#s19&quot;}, T, 2} where {var&quot;#s18&quot;, var&quot;#s19&quot;}), LinearAlgebra.Symmetric{T, var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(StaticArray{Tuple{var&quot;#s7&quot;, var&quot;#s8&quot;}, T, 2} where {var&quot;#s7&quot;, var&quot;#s8&quot;}), LinearAlgebra.Transpose{T, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.UnitLowerTriangular{T, var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(StaticArray{Tuple{var&quot;#s24&quot;, var&quot;#s25&quot;}, T, 2} where {var&quot;#s24&quot;, var&quot;#s25&quot;}), LinearAlgebra.UnitUpperTriangular{T, var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(StaticArray{Tuple{var&quot;#s21&quot;, var&quot;#s22&quot;}, T, 2} where {var&quot;#s21&quot;, var&quot;#s22&quot;}), LinearAlgebra.UpperTriangular{T, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(StaticArray{Tuple{var&quot;#s15&quot;, var&quot;#s16&quot;}, T, 2} where {var&quot;#s15&quot;, var&quot;#s16&quot;}), StaticArray{Tuple{var&quot;#s25&quot;}, T, 1} where var&quot;#s25&quot;, StaticArray{Tuple{var&quot;#s1&quot;, var&quot;#s3&quot;}, T, 2} where {var&quot;#s1&quot;, var&quot;#s3&quot;}} where T)}" href="#StaticArrays.multiplied_dimension-Tuple{Type{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(Union{LinearAlgebra.Adjoint{T, var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.Diagonal{T, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(StaticArray{Tuple{var&quot;#s13&quot;}, T, 1} where var&quot;#s13&quot;), LinearAlgebra.Hermitian{T, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(StaticArray{Tuple{var&quot;#s10&quot;, var&quot;#s11&quot;}, T, 2} where {var&quot;#s10&quot;, var&quot;#s11&quot;}), LinearAlgebra.LowerTriangular{T, var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(StaticArray{Tuple{var&quot;#s18&quot;, var&quot;#s19&quot;}, T, 2} where {var&quot;#s18&quot;, var&quot;#s19&quot;}), LinearAlgebra.Symmetric{T, var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(StaticArray{Tuple{var&quot;#s7&quot;, var&quot;#s8&quot;}, T, 2} where {var&quot;#s7&quot;, var&quot;#s8&quot;}), LinearAlgebra.Transpose{T, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.UnitLowerTriangular{T, var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(StaticArray{Tuple{var&quot;#s24&quot;, var&quot;#s25&quot;}, T, 2} where {var&quot;#s24&quot;, var&quot;#s25&quot;}), LinearAlgebra.UnitUpperTriangular{T, var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(StaticArray{Tuple{var&quot;#s21&quot;, var&quot;#s22&quot;}, T, 2} where {var&quot;#s21&quot;, var&quot;#s22&quot;}), LinearAlgebra.UpperTriangular{T, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(StaticArray{Tuple{var&quot;#s15&quot;, var&quot;#s16&quot;}, T, 2} where {var&quot;#s15&quot;, var&quot;#s16&quot;}), StaticArray{Tuple{var&quot;#s25&quot;}, T, 1} where var&quot;#s25&quot;, StaticArray{Tuple{var&quot;#s1&quot;, var&quot;#s3&quot;}, T, 2} where {var&quot;#s1&quot;, var&quot;#s3&quot;}} where T), Type{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Union{LinearAlgebra.Adjoint{T, var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.Diagonal{T, var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(StaticArray{Tuple{var&quot;#s13&quot;}, T, 1} where var&quot;#s13&quot;), LinearAlgebra.Hermitian{T, var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:(StaticArray{Tuple{var&quot;#s10&quot;, var&quot;#s11&quot;}, T, 2} where {var&quot;#s10&quot;, var&quot;#s11&quot;}), LinearAlgebra.LowerTriangular{T, var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(StaticArray{Tuple{var&quot;#s18&quot;, var&quot;#s19&quot;}, T, 2} where {var&quot;#s18&quot;, var&quot;#s19&quot;}), LinearAlgebra.Symmetric{T, var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(StaticArray{Tuple{var&quot;#s7&quot;, var&quot;#s8&quot;}, T, 2} where {var&quot;#s7&quot;, var&quot;#s8&quot;}), LinearAlgebra.Transpose{T, var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Union{StaticArray{Tuple{var&quot;#s2&quot;}, T, 1} where var&quot;#s2&quot;, StaticArray{Tuple{var&quot;#s3&quot;, var&quot;#s4&quot;}, T, 2} where {var&quot;#s3&quot;, var&quot;#s4&quot;}}, LinearAlgebra.UnitLowerTriangular{T, var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(StaticArray{Tuple{var&quot;#s24&quot;, var&quot;#s25&quot;}, T, 2} where {var&quot;#s24&quot;, var&quot;#s25&quot;}), LinearAlgebra.UnitUpperTriangular{T, var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(StaticArray{Tuple{var&quot;#s21&quot;, var&quot;#s22&quot;}, T, 2} where {var&quot;#s21&quot;, var&quot;#s22&quot;}), LinearAlgebra.UpperTriangular{T, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(StaticArray{Tuple{var&quot;#s15&quot;, var&quot;#s16&quot;}, T, 2} where {var&quot;#s15&quot;, var&quot;#s16&quot;}), StaticArray{Tuple{var&quot;#s25&quot;}, T, 1} where var&quot;#s25&quot;, StaticArray{Tuple{var&quot;#s1&quot;, var&quot;#s3&quot;}, T, 2} where {var&quot;#s1&quot;, var&quot;#s3&quot;}} where T)}"><code>StaticArrays.multiplied_dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiplied_dimension(A, B)</code></pre><p>Calculate the product of the dimensions being multiplied. Useful as a heuristic for unrolling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.pop-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}" href="#StaticArrays.pop-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}"><code>StaticArrays.pop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pop(vec::StaticVector)</code></pre><p>Return a new vector with the last item in <code>vec</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pop(@SVector[1,2,3])
2-element SVector{2, Int64} with indices SOneTo(2):
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L84-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.popfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}" href="#StaticArrays.popfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}"><code>StaticArrays.popfirst</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">popfirst(vec::StaticVector)</code></pre><p>Return a new vector with the first item in <code>vec</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; popfirst(@SVector[1,2,3])
2-element SVector{2, Int64} with indices SOneTo(2):
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L107-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.push-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}" href="#StaticArrays.push-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}"><code>StaticArrays.push</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push(vec::StaticVector, item)</code></pre><p>Return a new <code>StaticVector</code> with <code>item</code> inserted on the end of <code>vec</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push(@SVector[1, 2, 3], 4)
4-element SVector{4, Int64} with indices SOneTo(4):
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}" href="#StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}"><code>StaticArrays.pushfirst</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pushfirst(vec::StaticVector, item)</code></pre><p>Return a new <code>StaticVector</code> with <code>item</code> inserted at the beginning of <code>vec</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pushfirst(@SVector[1, 2, 3, 4], 5)
5-element SVector{5, Int64} with indices SOneTo(5):
 5
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/deque.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.sacollect" href="#StaticArrays.sacollect"><code>StaticArrays.sacollect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sacollect(SA, gen)</code></pre><p>Construct a statically-sized vector of type <code>SA</code>.from a generator <code>gen</code>. <code>SA</code> needs to have a size parameter since the length of <code>vec</code> is unknown to the compiler. <code>SA</code> can optionally specify the element type as well.</p><p>Example:</p><pre><code class="language-julia hljs">sacollect(SVector{3, Int}, 2i+1 for i in 1:3)
sacollect(SMatrix{2, 3}, i+j for i in 1:2, j in 1:3)
sacollect(SArray{2, 3}, i+j for i in 1:2, j in 1:3)</code></pre><p>This creates the same statically-sized vector as if the generator were collected in an array, but is more efficient since no array is allocated.</p><p>Equivalent:</p><pre><code class="language-julia hljs">SVector{3, Int}([2i+1 for i in 1:3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/SArray.jl#L30-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.same_size-Tuple" href="#StaticArrays.same_size-Tuple"><code>StaticArrays.same_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">same_size(as...)</code></pre><p>Returns the common <code>Size</code> of the inputs (or else throws a <code>DimensionMismatch</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/traits.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1}, Size{S2}}} where {S1, S2}" href="#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1}, Size{S2}}} where {S1, S2}"><code>StaticArrays.sizematch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sizematch(::Size, ::Size)
sizematch(::Tuple, ::Tuple)</code></pre><p>Determine whether two sizes match, in the sense that they have the same number of dimensions, and their dimensions match as determined by <a href="#StaticArrays.dimmatch"><code>dimmatch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/traits.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S}, StaticArray}} where S" href="#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S}, StaticArray}} where S"><code>StaticArrays.sizematch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sizematch(::Size, A::AbstractArray)</code></pre><p>Determine whether array <code>A</code> matches the given size. If <code>A</code> is a <code>StaticArray</code>, the check is performed at compile time, otherwise, the check is performed at runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/traits.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.uplo_access-NTuple{5, Any}" href="#StaticArrays.uplo_access-NTuple{5, Any}"><code>StaticArrays.uplo_access</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uplo_access(sa, asym, k, j, uplo)</code></pre><p>Generate code for matrix element access, for a matrix of size <code>sa</code> locally referred to as <code>asym</code> in the context where the result will be used. Both indices <code>k</code> and <code>j</code> need to be statically known for this function to work. <code>uplo</code> is the access pattern mode generated by the <code>gen_by_access</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/matrix_multiply_add.jl#L277-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.@MArray-Tuple{Any}" href="#StaticArrays.@MArray-Tuple{Any}"><code>StaticArrays.@MArray</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@MArray [a b; c d]
@MArray [[a, b];[c, d]]
@MArray [i+j for i in 1:2, j in 1:2]
@MArray ones(2, 2, 2)</code></pre><p>A convenience macro to construct <code>MArray</code> with arbitrary dimension. See <a href="#StaticArrays.@SArray-Tuple{Any}"><code>@SArray</code></a> for detailed features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/MArray.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.@MMatrix-Tuple{Any}" href="#StaticArrays.@MMatrix-Tuple{Any}"><code>StaticArrays.@MMatrix</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@MMatrix [a b c d]
@MMatrix [[a, b];[c, d]]
@MMatrix [i+j for i in 1:2, j in 1:2]
@MMatrix ones(2, 2)</code></pre><p>A convenience macro to construct <code>MMatrix</code>. See <a href="#StaticArrays.@SArray-Tuple{Any}"><code>@SArray</code></a> for detailed features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/MMatrix.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.@MVector-Tuple{Any}" href="#StaticArrays.@MVector-Tuple{Any}"><code>StaticArrays.@MVector</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@MVector [a, b, c, d]
@MVector [i for i in 1:2]
@MVector ones(2)</code></pre><p>A convenience macro to construct <code>MVector</code>. See <a href="#StaticArrays.@SArray-Tuple{Any}"><code>@SArray</code></a> for detailed features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/MVector.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.@SArray-Tuple{Any}" href="#StaticArrays.@SArray-Tuple{Any}"><code>StaticArrays.@SArray</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@SArray [a b; c d]
@SArray [[a, b];[c, d]]
@SArray [i+j for i in 1:2, j in 1:2]
@SArray ones(2, 2, 2)</code></pre><p>A convenience macro to construct <code>SArray</code> with arbitrary dimension. It supports:</p><ol><li><p>(typed) array literals.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Every argument inside the square brackets is treated as a scalar during expansion. Thus <code>@SArray[a; b]</code> always forms a <code>SVector{2}</code> and <code>@SArray [a b; c]</code> always throws an error.</p></div></div></li><li><p>comprehensions</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The range of a comprehension is evaluated at global scope by the macro, and must be made of combinations of literal values, functions, or global variables.</p></div></div></li><li><p>initialization functions</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only support <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code>, <code>randn()</code>, and <code>randexp()</code></p></div></div></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/SArray.jl#L301-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.@SMatrix-Tuple{Any}" href="#StaticArrays.@SMatrix-Tuple{Any}"><code>StaticArrays.@SMatrix</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@SMatrix [a b c d]
@SMatrix [[a, b];[c, d]]
@SMatrix [i+j for i in 1:2, j in 1:2]
@SMatrix ones(2, 2)</code></pre><p>A convenience macro to construct <code>SMatrix</code>. See <a href="#StaticArrays.@SArray-Tuple{Any}"><code>@SArray</code></a> for detailed features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/SMatrix.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArrays.@SVector-Tuple{Any}" href="#StaticArrays.@SVector-Tuple{Any}"><code>StaticArrays.@SVector</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@SVector [a, b, c, d]
@SVector [i for i in 1:2]
@SVector ones(2)</code></pre><p>A convenience macro to construct <code>SVector</code>. See <a href="#StaticArrays.@SArray-Tuple{Any}"><code>@SArray</code></a> for detailed features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArrays.jl/blob/f4dbc15410b6d939be1c7cb76ef6cb5b7c0fafd7/src/SVector.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.Dynamic" href="#StaticArraysCore.Dynamic"><code>StaticArraysCore.Dynamic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dynamic()</code></pre><p>Used to signify that a dimension of an array is not known statically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L439-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.FieldArray" href="#StaticArraysCore.FieldArray"><code>StaticArraysCore.FieldArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract FieldArray{N, T, D} &lt;: StaticArray{N, T, D}</code></pre><p>Inheriting from this type will make it easy to create your own rank-D tensor types. A <code>FieldArray</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldArray</code> will be as performant as an <code>SArray</code> of similar length and element type, while a mutable <code>FieldArray</code> will behave similarly to an <code>MArray</code>.</p><p>Note that you must define the fields of any <code>FieldArray</code> subtype in column major order. If you want to use an alternative ordering you will need to pay special attention in providing your own definitions of <code>getindex</code>, <code>setindex!</code> and tuple conversion.</p><p>If you define a <code>FieldArray</code> which is parametric on the element type you should consider defining <code>similar_type</code> as in the <code>FieldVector</code> example.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">struct Stiffness &lt;: FieldArray{Tuple{2,2,2,2}, Float64, 4}
    xxxx::Float64
    yxxx::Float64
    xyxx::Float64
    yyxx::Float64
    xxyx::Float64
    yxyx::Float64
    xyyx::Float64
    yyyx::Float64
    xxxy::Float64
    yxxy::Float64
    xyxy::Float64
    yyxy::Float64
    xxyy::Float64
    yxyy::Float64
    xyyy::Float64
    yyyy::Float64
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L300-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.FieldMatrix" href="#StaticArraysCore.FieldMatrix"><code>StaticArraysCore.FieldMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract FieldMatrix{N1, N2, T} &lt;: FieldArray{Tuple{N1, N2}, 2}</code></pre><p>Inheriting from this type will make it easy to create your own rank-two tensor types. A <code>FieldMatrix</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldMatrix</code> will be as performant as an <code>SMatrix</code> of similar length and element type, while a mutable <code>FieldMatrix</code> will behave similarly to an <code>MMatrix</code>.</p><p>Note that the fields of any subtype of <code>FieldMatrix</code> must be defined in column major order unless you are willing to implement your own <code>getindex</code>.</p><p>If you define a <code>FieldMatrix</code> which is parametric on the element type you should consider defining <code>similar_type</code> as in the <code>FieldVector</code> example.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">struct Stress &lt;: FieldMatrix{3, 3, Float64}
    xx::Float64
    yx::Float64
    zx::Float64
    xy::Float64
    yy::Float64
    zy::Float64
    xz::Float64
    yz::Float64
    zz::Float64
end</code></pre><p>Note that the fields of any subtype of <code>FieldMatrix</code> must be defined in column major order.  This means that formatting of constructors for literal <code>FieldMatrix</code> can be confusing. For example</p><pre><code class="nohighlight hljs">sigma = Stress(1.0, 2.0, 3.0,
               4.0, 5.0, 6.0,
               7.0, 8.0, 9.0)

3×3 Stress:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>will give you the transpose of what the multi-argument formatting suggests. For clarity, you may consider using the alternative</p><pre><code class="nohighlight hljs">sigma = Stress(SA[1.0 2.0 3.0;
                  4.0 5.0 6.0;
                  7.0 8.0 9.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L339-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.FieldVector" href="#StaticArraysCore.FieldVector"><code>StaticArraysCore.FieldVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract FieldVector{N, T} &lt;: FieldArray{Tuple{N}, 1}</code></pre><p>Inheriting from this type will make it easy to create your own vector types. A <code>FieldVector</code> will automatically define <code>getindex</code> and <code>setindex!</code> appropriately. An immutable <code>FieldVector</code> will be as performant as an <code>SVector</code> of similar length and element type, while a mutable <code>FieldVector</code> will behave similarly to an <code>MVector</code>.</p><p>If you define a <code>FieldVector</code> which is parametric on the element type you should consider defining <code>similar_type</code> to preserve your array type through array operations as in the example below.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">struct Vec3D{T} &lt;: FieldVector{3, T}
    x::T
    y::T
    z::T
end

StaticArrays.similar_type(::Type{&lt;:Vec3D}, ::Type{T}, s::Size{(3,)}) where {T} = Vec3D{T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L388-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.MArray" href="#StaticArraysCore.MArray"><code>StaticArraysCore.MArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MArray{S, T, N, L}(undef)
MArray{S, T, N, L}(x::NTuple{L})
MArray{S, T, N, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable array <code>MArray</code>. The data may optionally be provided upon construction and can be mutated later. The <code>S</code> parameter is a Tuple-type specifying the dimensions, or size, of the array - such as <code>Tuple{3,4,5}</code> for a 3×4×5-sized array. The <code>N</code> parameter is the dimension of the array; the <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>prod(S)</code>. Constructors may drop the <code>L</code>, <code>N</code> and <code>T</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S</code>).</p><pre><code class="nohighlight hljs">MArray{S}(a::Array)</code></pre><p>Construct a statically-sized, mutable array of dimensions <code>S</code> (expressed as a <code>Tuple{...}</code>) using the data from <code>a</code>. The <code>S</code> parameter is mandatory since the size of <code>a</code> is unknown to the compiler (the element type may optionally also be specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L163-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.MMatrix" href="#StaticArraysCore.MMatrix"><code>StaticArraysCore.MMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MMatrix{S1, S2, T, L}(undef)
MMatrix{S1, S2, T, L}(x::NTuple{L, T})
MMatrix{S1, S2, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable matrix <code>MMatrix</code>. The data may optionally be provided upon construction and can be mutated later. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>S1 * S2</code>. Constructors may drop the <code>L</code>, <code>T</code> and even <code>S2</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S1</code> and <code>S2</code>).</p><pre><code class="nohighlight hljs">MMatrix{S1, S2}(mat::Matrix)</code></pre><p>Construct a statically-sized, mutable matrix of dimensions <code>S1 × S2</code> using the data from <code>mat</code>. The parameters <code>S1</code> and <code>S2</code> are mandatory since the size of <code>mat</code> is unknown to the compiler (the element type may optionally also be specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L221-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.MVector" href="#StaticArraysCore.MVector"><code>StaticArraysCore.MVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MVector{S,T}(undef)
MVector{S,T}(x::NTuple{S, T})
MVector{S,T}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized, mutable vector <code>MVector</code>. Data may optionally be provided upon construction, and can be mutated later. Constructors may drop the <code>T</code> and <code>S</code> parameters if they are inferrable from the input (e.g. <code>MVector(1,2,3)</code> constructs an <code>MVector{3, Int}</code>).</p><pre><code class="nohighlight hljs">MVector{S}(vec::Vector)</code></pre><p>Construct a statically-sized, mutable vector of length <code>S</code> using the data from <code>vec</code>. The parameter <code>S</code> is mandatory since the length of <code>vec</code> is unknown to the compiler (the element type may optionally also be specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L203-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.SArray" href="#StaticArraysCore.SArray"><code>StaticArraysCore.SArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SArray{S, T, N, L}(x::NTuple{L})
SArray{S, T, N, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized array <code>SArray</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The <code>S</code> parameter is a Tuple-type specifying the dimensions, or size, of the array - such as <code>Tuple{3,4,5}</code> for a 3×4×5-sized array. The <code>N</code> parameter is the dimension of the array; the <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>prod(S)</code>. Constructors may drop the <code>L</code>, <code>N</code> and <code>T</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S</code>).</p><pre><code class="nohighlight hljs">SArray{S}(a::Array)</code></pre><p>Construct a statically-sized array of dimensions <code>S</code> (expressed as a <code>Tuple{...}</code>) using the data from <code>a</code>. The <code>S</code> parameter is mandatory since the size of <code>a</code> is unknown to the compiler (the element type may optionally also be specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L93-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.SMatrix" href="#StaticArraysCore.SMatrix"><code>StaticArraysCore.SMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SMatrix{S1, S2, T, L}(x::NTuple{L, T})
SMatrix{S1, S2, T, L}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized matrix <code>SMatrix</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The <code>L</code> parameter is the <code>length</code> of the array and is always equal to <code>S1 * S2</code>. Constructors may drop the <code>L</code>, <code>T</code> and even <code>S2</code> parameters if they are inferrable from the input (e.g. <code>L</code> is always inferrable from <code>S1</code> and <code>S2</code>).</p><pre><code class="nohighlight hljs">SMatrix{S1, S2}(mat::Matrix)</code></pre><p>Construct a statically-sized matrix of dimensions <code>S1 × S2</code> using the data from <code>mat</code>. The parameters <code>S1</code> and <code>S2</code> are mandatory since the size of <code>mat</code> is unknown to the compiler (the element type may optionally also be specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L143-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.SVector" href="#StaticArraysCore.SVector"><code>StaticArraysCore.SVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SVector{S, T}(x::NTuple{S, T})
SVector{S, T}(x1, x2, x3, ...)</code></pre><p>Construct a statically-sized vector <code>SVector</code>. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. Constructors may drop the <code>T</code> and <code>S</code> parameters if they are inferrable from the input (e.g. <code>SVector(1,2,3)</code> constructs an <code>SVector{3, Int}</code>).</p><pre><code class="nohighlight hljs">SVector{S}(vec::Vector)</code></pre><p>Construct a statically-sized vector of length <code>S</code> using the data from <code>vec</code>. The parameter <code>S</code> is mandatory since the length of <code>vec</code> is unknown to the compiler (the element type may optionally also be specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.Size" href="#StaticArraysCore.Size"><code>StaticArraysCore.Size</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Size(dims::Int...)</code></pre><p><code>Size</code> is used extensively throughout the <code>StaticArrays</code> API to describe <em>compile-time</em> knowledge of the size of an array. The dimensions are stored as a type parameter and are statically propagated by the compiler, resulting in efficient, type-inferrable code. For example, to create a static matrix of zeros, use <code>A = zeros(SMatrix{3,3})</code>. The static size of <code>A</code> can be obtained by <code>Size(A)</code>. (rather than <code>size(zeros(3,3))</code>, which returns <code>Base.Tuple{2,Int}</code>).</p><p>Note that if dimensions are not known statically (e.g., for standard <code>Array</code>s), <a href="#StaticArraysCore.Dynamic"><code>Dynamic()</code></a> should be used instead of an <code>Int</code>.</p><pre><code class="nohighlight hljs">Size(a::AbstractArray)
Size(::Type{T&lt;:AbstractArray})</code></pre><p>The <code>Size</code> constructor can be used to extract static dimension information from a given array. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; Size(zeros(SMatrix{3, 4}))
Size(3, 4)

julia&gt; Size(zeros(3, 4))
Size(StaticArrays.Dynamic(), StaticArrays.Dynamic())</code></pre><p>This has multiple uses, including &quot;trait&quot;-based dispatch on the size of a statically-sized array. For example:</p><pre><code class="language-julia hljs">det(x::StaticMatrix) = _det(Size(x), x)
_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]
_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]
# and other definitions as necessary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L448-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.SizedArray" href="#StaticArraysCore.SizedArray"><code>StaticArraysCore.SizedArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SizedArray{Tuple{dims...}}(array)</code></pre><p>Wraps an <code>AbstractArray</code> with a static size, so to take advantage of the (faster) methods defined by StaticArrays.jl. The size is checked once upon construction to determine if the number of elements (<code>length</code>) match, but the array may be reshaped.</p><p>The aliases <code>SizedVector{N}</code> and <code>SizedMatrix{N,M}</code> are provided as more convenient names for one and two dimensional <code>SizedArray</code>s. For example, to wrap a 2x3 array <code>a</code> in a <code>SizedArray</code>, use <code>SizedMatrix{2,3}(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L246-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.SizedMatrix" href="#StaticArraysCore.SizedMatrix"><code>StaticArraysCore.SizedMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SizedMatrix{S1,S2,T} = SizedArray{Tuple{S1,S2},T,2}</code></pre><p>Wraps a two-dimensional <code>AbstractArray</code> with static dimensions <code>S1</code> by <code>S2</code> and element type <code>T</code>, leveraging the performance optimizations of StaticArrays.jl.</p><p>For detailed usage and functionality, refer to the documentation of <code>SizedArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L288-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.SizedVector" href="#StaticArraysCore.SizedVector"><code>StaticArraysCore.SizedVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SizedVector{S, T} = SizedArray{Tuple{S}, T, 1, 1}</code></pre><p>Wraps a one-dimensional <code>AbstractArray</code> with static length <code>S</code> and element type <code>T</code>, leveraging the performance optimizations of StaticArrays.jl.</p><p>For detailed usage and functionality, refer to the documentation of <code>SizedArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L278-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.StaticArray" href="#StaticArraysCore.StaticArray"><code>StaticArraysCore.StaticArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type StaticArray{S, T, N} &lt;: AbstractArray{T, N} end
StaticScalar{T}     = StaticArray{Tuple{}, T, 0}
StaticVector{N,T}   = StaticArray{Tuple{N}, T, 1}
StaticMatrix{N,M,T} = StaticArray{Tuple{N,M}, T, 2}</code></pre><p><code>StaticArray</code>s are Julia arrays with fixed, known size.</p><p><strong>Dev docs</strong></p><p>They must define the following methods:</p><ul><li>Constructors that accept a flat tuple of data.</li><li><code>getindex()</code> with an integer (linear indexing) (preferably <code>@inline</code> with <code>@boundscheck</code>).</li><li><code>Tuple()</code>, returning the data in a flat Tuple.</li></ul><p>It may be useful to implement:</p><ul><li><code>similar_type(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize})</code>, returning a type (or type constructor) that accepts a flat tuple of data.</li></ul><p>For mutable containers you may also need to define the following:</p><ul><li><code>setindex!</code> for a single element (linear indexing).</li><li><code>similar(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize})</code>.</li><li>In some cases, a zero-parameter constructor, <code>MyStaticArray{...}()</code> for unintialized data is assumed to exist.</li></ul><p>(see also <code>SVector</code>, <code>SMatrix</code>, <code>SArray</code>, <code>MVector</code>, <code>MMatrix</code>, <code>MArray</code>, <code>SizedArray</code>, <code>FieldVector</code>, <code>FieldMatrix</code> and <code>FieldArray</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.similar_type" href="#StaticArraysCore.similar_type"><code>StaticArraysCore.similar_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar_type(static_array)
similar_type(static_array, T)
similar_type(array, ::Size)
similar_type(array, T, ::Size)</code></pre><p>Returns a constructor for a statically-sized array similar to the input array (or type) <code>static_array</code>/<code>array</code>, optionally with different element type <code>T</code> or size <code>Size</code>. If the input <code>array</code> is not a <code>StaticArray</code> then the <code>Size</code> is mandatory.</p><p>This differs from <code>similar()</code> in that the resulting array type may not be mutable (or define <code>setindex!()</code>), and therefore the returned type may need to be <em>constructed</em> with its data.</p><p>Note that the (optional) size <em>must</em> be specified as a static <code>Size</code> object (so the compiler can infer the result statically).</p><p>New types should define the signature <code>similar_type(::Type{A},::Type{T},::Size{S}) where {A&lt;:MyType,T,S}</code> if they wish to overload the default behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L417-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StaticArraysCore.size_to_tuple-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Tuple" href="#StaticArraysCore.size_to_tuple-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Tuple"><code>StaticArraysCore.size_to_tuple</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size_to_tuple(::Type{S}) where S&lt;:Tuple</code></pre><p>Converts a size given by <code>Tuple{N, M, ...}</code> into a tuple <code>(N, M, ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/StaticArraysCore.jl/blob/v1.4.3/src/StaticArraysCore.jl#L63-L67">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../quickstart/">Quick Start »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 26 December 2024 17:02">Thursday 26 December 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
