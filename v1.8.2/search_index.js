var documenterSearchIndex = {"docs":
[{"location":"pages/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"pages/api/#Guide","page":"API","title":"Guide","text":"","category":"section"},{"location":"pages/api/#SVector","page":"API","title":"SVector","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"The simplest static array is the type SVector{N,T}, which provides an immutable vector of fixed length N and type T.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"SVector defines a series of convenience constructors, so you can just type e.g. SVector(1,2,3). Alternatively there is an intelligent @SVector macro where you can use native Julia array literals syntax, comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as @SVector [1,2,3], @SVector Float64[1,2,3], @SVector [f(i) for i = 1:10], @SVector zeros(3), @SVector randn(Float32, 4), etc (Note: the range of a comprehension is evaluated at global scope by the macro, and must be made of combinations of literal values, functions, or global variables, but is not limited to just simple ranges. Extending this to (hopefully statically known by type-inference) local-scope variables is hoped for the future. The zeros(), ones(), fill(), rand(), randn(), and randexp() functions do not have this limitation.)","category":"page"},{"location":"pages/api/#SMatrix","page":"API","title":"SMatrix","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Statically sized N×M matrices are provided by SMatrix{N,M,T,L}.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Here L is the length of the matrix, such that N × M = L. However, convenience constructors are provided, so that L, T and even M are unnecessary. At minimum, you can type SMatrix{2}(1,2,3,4) to create a 2×2 matrix (the total number of elements must divide evenly into N). A convenience macro @SMatrix [1 2; 3 4] is provided (which also accepts comprehensions and the zeros(), ones(), fill(), rand(), randn(), and randexp() functions).","category":"page"},{"location":"pages/api/#SArray","page":"API","title":"SArray","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"A container with arbitrarily many dimensions is defined as struct SArray{Size,T,N,L} <: StaticArray{Size,T,N}, where Size = Tuple{S1, S2, ...} is a tuple of Ints. You can easily construct one with the @SArray macro, supporting all the features of @SVector and @SMatrix (but with arbitrary dimension).","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"The main reason SVector and SMatrix are defined is to make it easier to define the types without the extra tuple characters (compare SVector{3} to SArray{Tuple{3}}).","category":"page"},{"location":"pages/api/#Scalar","page":"API","title":"Scalar","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Sometimes you want to broadcast an operation, but not over one of your inputs. A classic example is attempting to displace a collection of vectors by the same vector. We can now do this with the Scalar type:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"[[1,2,3], [4,5,6]] .+ Scalar([1,0,-1]) # [[2,2,2], [5,5,5]]","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Scalar is simply an implementation of an immutable, 0-dimensional StaticArray.","category":"page"},{"location":"pages/api/#The-Size-trait","page":"API","title":"The Size trait","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"The size of a statically sized array is a static parameter associated with the type of the array. The Size trait is provided as an abstract representation of the dimensions of a static array. An array sa::SA of size (dims...) is associated with Size{(dims...)}(). The following are equivalent (@pure) constructors:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Size{(dims...,)}()\nSize(dims...)\nSize(sa::StaticArray)\nSize(SA) # SA <: StaticArray","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"This is extremely useful for (a) performing dispatch depending on the size of an array, and (b) passing array dimensions that the compiler can reason about.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"An example of size-based dispatch for the determinant of a matrix would be:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"det(x::StaticMatrix) = _det(Size(x), x)\n_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]\n_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]\n# and other definitions as necessary","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Examples of using Size as a compile-time constant include","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"reshape(svector, Size(2,2))  # Convert SVector{4} to SMatrix{2,2}\nSizedMatrix{3,3}(rand(3,3))  # Construct a random 3×3 SizedArray (see below)","category":"page"},{"location":"pages/api/#Indexing","page":"API","title":"Indexing","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Statically sized indexing can be realized by indexing each dimension by a scalar, a StaticVector or :. Indexing in this way will result a statically sized array (even if the input was dynamically sized, in the case of StaticVector indices) of the closest type (as defined by similar_type).","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Conversely, indexing a statically sized array with a dynamically sized index (such as a Vector{Integer} or UnitRange{Integer}) will result in a standard (dynamically sized) Array.","category":"page"},{"location":"pages/api/#similar_type()","page":"API","title":"similar_type()","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Since immutable arrays need to be constructed \"all-at-once\", we need a way of obtaining an appropriate constructor if the element type or dimensions of the output array differs from the input. To this end, similar_type is introduced, behaving just like similar, except that it returns a type. Relevant methods are:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"similar_type(::Type{A}) where {A <: StaticArray} # defaults to A\nsimilar_type(::Type{A}, ::Type{ElType}) where {A <: StaticArray, ElType} # Change element type\nsimilar_type(::Type{A}, size::Size) where {A <: AbstractArray} # Change size\nsimilar_type(::Type{A}, ::Type{ElType}, size::Size) where {A <: AbstractArray, ElType} # Change both","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"These setting will affect everything, from indexing, to matrix multiplication and broadcast. Users wanting introduce a new array type should only overload the last method in the above.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Use of similar will fall back to a mutable container, such as a MVector (see below), and it requires use of the Size trait if you wish to set a new static size (or else a dynamically sized Array will be generated when specifying the size as plain integers).","category":"page"},{"location":"pages/api/#Collecting-directly-into-static-arrays","page":"API","title":"Collecting directly into static arrays","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"You can collect iterators into static arrays directly with StaticArrays.sacollect. The size needs to be specified, but the element type is optional.","category":"page"},{"location":"pages/api/#Mutable-arrays:-MVector,-MMatrix-and-MArray","page":"API","title":"Mutable arrays: MVector, MMatrix and MArray","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"These statically sized arrays are identical to the above, but are defined as mutable structs, instead of immutable structs. Because they are mutable, they allow setindex! to be defined (achieved through pointer manipulation, into a tuple).","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"As a consequence of Julia's internal implementation, these mutable containers live on the heap, not the stack. Their memory must be allocated and tracked by the garbage collector. Nevertheless, there is opportunity for speed improvements relative to Base.Array because (a) there may be one less pointer indirection, (b) their (typically small) static size allows for additional loop unrolling and inlining, and consequentially (c) their mutating methods like map! are extremely fast. Benchmarking shows that operations such as addition and matrix multiplication are faster for MMatrix than Matrix, at least for sizes up to 14 × 14, though keep in mind that optimal speed will be obtained by using mutating functions (like map! or A_mul_B!) where possible, rather than reallocating new memory.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Mutable static arrays also happen to be very useful containers that can be constructed on the heap (with the ability to use setindex!, etc), and later copied as e.g. an immutable SVector to the stack for use, or into e.g. an Array{SVector} for storage.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Convenience macros @MVector, @MMatrix and @MArray are provided.","category":"page"},{"location":"pages/api/#SizedArray:-a-decorate-size-wrapper-for-Array","page":"API","title":"SizedArray: a decorate size wrapper for Array","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Another convenient mutable type is the SizedArray, which is just a wrapper-type about a standard Julia Array which declares its known size. For example, if we knew that a was a 2×2 Matrix, then we can type sa = SizedArray{Tuple{2,2}}(a) to construct a new object which knows the type (the size will be verified automatically). For one and two dimensions, a more convenient syntax for obtaining a SizedArray is by using the SizedMatrix and SizedVector aliases, e.g. sa = SizedMatrix{2,2}(a).","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Then, methods on sa will use the specialized code provided by the StaticArrays package, which in many cases will be much, much faster. For example, calling eigen(sa) will be significantly faster than eigen(a) since it will perform a specialized 2×2 matrix diagonalization rather than a general algorithm provided by Julia and LAPACK.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"In some cases it will make more sense to use a SizedArray, and in other cases an MArray might be preferable.","category":"page"},{"location":"pages/api/#FieldVector","page":"API","title":"FieldVector","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Sometimes it is useful to give your own struct types the properties of a vector. StaticArrays can take care of this for you by allowing you to inherit from FieldVector{N, T}. For example, consider:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"struct Point3D <: FieldVector{3, Float64}\n    x::Float64\n    y::Float64\n    z::Float64\nend","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"With this type, users can easily access fields to p = Point3D(x,y,z) using p.x, p.y or p.z, or alternatively via p[1], p[2], or p[3]. You may even permute the coordinates with p[SVector(3,2,1)]). Furthermore, Point3D is a complete AbstractVector implementation where you can add, subtract or scale vectors, multiply them by matrices, etc.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Note: the three components of an ordinary v::SVector{3} can also be accessed as v.x, v.y, and v.z, so there is no need for a FieldVector to use this convention.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"It is also worth noting that FieldVectors may be mutable or immutable, and that setindex! is defined for use on mutable types. For immutable containers, you may want to define a method for similar_type so that operations leave the type constant (otherwise they may fall back to SVector). For mutable containers, you may want to define a default constructor (no inputs) and an appropriate method for similar,","category":"page"},{"location":"pages/api/#Implementing-your-own-types","page":"API","title":"Implementing your own types","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"You can easily create your own StaticArray type, by defining linear getindex (and optionally setindex! for mutable types –- see setindex!(::MArray, val, i) in MArray.jl for an example of how to achieve this through pointer manipulation). Your type should define a constructor that takes a tuple of the data (and mutable containers may want to define a default constructor).","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Other useful functions to overload may be similar_type (and similar for mutable containers).","category":"page"},{"location":"pages/api/#Conversions-from-Array","page":"API","title":"Conversions from Array","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"In order to convert from a dynamically sized AbstractArray to one of the statically sized array types, you must specify the size explicitly.  For example,","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"v = [1,2]\n\nm = [1 2;\n     3 4]\n\n# ... a lot of intervening code\n\nsv = SVector{2}(v)\nsm = SMatrix{2,2}(m)\nsa = SArray{Tuple{2,2}}(m)\n\nsized_v = SizedVector{2}(v)\nsized_m = SizedMatrix{2,2}(m)","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"We have avoided adding SVector(v::AbstractVector) as a valid constructor to help users avoid the type instability (and potential performance disaster, if used without care) of this innocuous looking expression.","category":"page"},{"location":"pages/api/#Arrays-of-static-arrays","page":"API","title":"Arrays of static arrays","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Storing a large number of static arrays is convenient as an array of static arrays. For example, a collection of positions (3D coordinates –- SVector{3,Float64}) could be represented as a Vector{SVector{3,Float64}}.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Another common way of storing the same data is as a 3×N Matrix{Float64}. Rather conveniently, such types have exactly the same binary layout in memory, and therefore we can use reinterpret to convert between the two formats","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"function svectors(x::Matrix{T}, ::Val{N}) where {T,N}\n    size(x,1) == N || error(\"sizes mismatch\")\n    isbitstype(T) || error(\"use for bitstypes only\")\n    reinterpret(SVector{N,T}, vec(x))\nend","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Such a conversion does not copy the data, rather it refers to the same memory. Arguably, a Vector of SVectors is often preferable to a Matrix because it provides a better abstraction of the objects contained in the array and it allows the fast StaticArrays methods to act on elements.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"However, the resulting object is a Base.ReinterpretArray, not an Array, which carries some runtime penalty on every single access. If you can afford the memory for a copy and can live with the non-shared mutation semantics, then it is better to pull a copy by e.g.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"function svectorscopy(x::Matrix{T}, ::Val{N}) where {T,N}\n    size(x,1) == N || error(\"sizes mismatch\")\n    isbitstype(T) || error(\"use for bitstypes only\")\n    copy(reinterpret(SVector{N,T}, vec(x)))\nend","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"For example:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"julia> M=reshape(collect(1:6), (2,3))\n2×3 Array{Int64,2}:\n 1  3  5\n 2  4  6\n\njulia> svectors(M, Val{2}())\n3-element reinterpret(SArray{Tuple{2},Int64,1,2}, ::Array{Int64,1}):\n [1, 2]\n [3, 4]\n [5, 6]\n\njulia> svectorscopy(M, Val{2}())\n3-element Array{SArray{Tuple{2},Int64,1,2},1}:\n [1, 2]\n [3, 4]\n [5, 6]","category":"page"},{"location":"pages/api/#Working-with-mutable-and-immutable-arrays","page":"API","title":"Working with mutable and immutable arrays","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Generally, it is performant to rebind an immutable array, such as","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"function average_position(positions::Vector{SVector{3,Float64}})\n    x = zeros(SVector{3,Float64})\n    for pos ∈ positions\n        x = x + pos\n    end\n    return x / length(positions)\nend","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"so long as the Type of the rebound variable (x, above) does not change.","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"On the other hand, the above code for mutable containers like Array, MArray or SizedArray is not very efficient. Mutable containers must be allocated and later garbage collected, and for small, fixed-size arrays this can be a leading contribution to the cost. In the above code, a new array will be instantiated and allocated on each iteration of the loop. In order to avoid unnecessary allocations, it is best to allocate an array only once and apply mutating functions to it:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"function average_position(positions::Vector{SVector{3,Float64}})\n    x = zeros(MVector{3,Float64})\n    for pos ∈ positions\n        x .+= pos\n    end\n    x ./= length(positions)\n    return x\nend","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"The functions setindex, push, pop, pushfirst, popfirst, insert and deleteat are provided for performing certain specific operations on static arrays, in analogy with the standard functions setindex!, push!, pop!, etc. (Note that if the size of the static array changes, the type of the output will differ from the input.)","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"When building static arrays iteratively, it is usually efficient to build up an MArray first and then convert. The allocation will be elided by recent Julia compilers, resulting in very efficient code:","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"function standard_basis_vector(T, ::Val{I}, ::Val{N}) where {I,N}\n    v = zero(MVector{N,T})\n    v[I] = one(T)\n    SVector(v)\nend","category":"page"},{"location":"pages/api/#SIMD-optimizations","page":"API","title":"SIMD optimizations","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"It seems Julia and LLVM are smart enough to use processor vectorization extensions like SSE and AVX - however they are currently partially disabled by default. Run Julia with julia -O or julia -O3 to enable these optimizations, and many of your (immutable) StaticArray methods should become significantly faster!","category":"page"},{"location":"pages/api/#Docstrings","page":"API","title":"Docstrings","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Pages   = [\"api.md\"]","category":"page"},{"location":"pages/api/","page":"API","title":"API","text":"Modules = [StaticArrays, StaticArraysCore]","category":"page"},{"location":"pages/api/#StaticArrays.StaticMatMulLike","page":"API","title":"StaticArrays.StaticMatMulLike","text":"StaticMatMulLike\n\nStatic wrappers used for multiplication dispatch.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays.Args","page":"API","title":"StaticArrays.Args","text":"Args\n\nA help wrapper to distinguish SA(x...) and SA((x...,))\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays.SA","page":"API","title":"StaticArrays.SA","text":"SA[ elements ]\nSA{T}[ elements ]\n\nCreate SArray literals using array construction syntax. The element type is inferred by promoting elements to a common type or set to T when T is provided explicitly.\n\nExamples:\n\nSA[1.0, 2.0] creates a length-2 SVector of Float64 elements.\nSA[1 2; 3 4] creates a 2×2 SMatrix of Ints.\nSA[1 2] creates a 1×2 SMatrix of Ints.\nSA{Float32}[1, 2] creates a length-2 SVector of Float32 elements.\n\nA couple of helpful type aliases are also provided:\n\nSA_F64[1, 2] creates a length-2 SVector of Float64 elements\nSA_F32[1, 2] creates a length-2 SVector of Float32 elements\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays.SHermitianCompact","page":"API","title":"StaticArrays.SHermitianCompact","text":"SHermitianCompact{N, T, L} <: StaticMatrix{N, N, T}\n\nA StaticArray subtype that represents a Hermitian matrix. Unlike LinearAlgebra.Hermitian, SHermitianCompact stores only the lower triangle of the matrix (as an SVector). The lower triangle is stored in column-major order. For example, for an SHermitianCompact{3}, the indices of the stored elements can be visualized as follows:\n\n┌ 1 ⋅ ⋅ ┐\n| 2 4 ⋅ |\n└ 3 5 6 ┘\n\nType parameters:\n\nN: matrix dimension;\nT: element type for lower triangle;\nL: length of the SVector storing the lower triangular elements.\n\nNote that L is always the Nth triangular number.\n\nAn SHermitianCompact may be constructed either:\n\nfrom an AbstractVector containing the lower triangular elements; or\nfrom a Tuple containing both upper and lower triangular elements in column major order; or\nfrom another StaticMatrix.\n\nFor the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays.SOneTo","page":"API","title":"StaticArrays.SOneTo","text":"SOneTo(n)\n\nReturn a statically-sized AbstractUnitRange starting at 1, functioning as the axes of a StaticArray.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays.Scalar","page":"API","title":"StaticArrays.Scalar","text":"Scalar{T}(x::T)\n\nConstruct a statically-sized 0-dimensional array that contains a single element, x. This type is particularly useful for influencing broadcasting operations.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays.TSize","page":"API","title":"StaticArrays.TSize","text":"Size that stores whether a Matrix is a Transpose Useful when selecting multiplication methods, and avoiding allocations when dealing with the Transpose type by passing around the original matrix. Should pair with parent.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArrays._InitialValue","page":"API","title":"StaticArrays._InitialValue","text":"_InitialValue\n\nA singleton type for representing \"universal\" initial value (identity element).\n\nThe idea is that, given op for mapfoldl, virtually, we define an \"extended\" version of it by\n\nop′(::_InitialValue, x) = x\nop′(acc, x) = op(acc, x)\n\nThis is just a conceptually useful model to have in mind and we don't actually define op′ here  (yet?).  But see Base.BottomRF for how it might work in action.\n\n(It is related to that you can always turn a semigroup without an identity into a monoid by \"adjoining\" an element that acts as the identity.)\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#Base.setindex-Tuple{StaticArray, Any, Int64}","page":"API","title":"Base.setindex","text":"setindex(vec::StaticArray, x, index::Int)\n\nReturn a new array with the item at index replaced by x.\n\nExamples\n\njulia> setindex(@SVector[1,2,3], 4, 2)\n3-element SVector{3, Int64} with indices SOneTo(3):\n 1\n 4\n 3\n\njulia> setindex(@SMatrix[2 4; 6 8], 1, 2)\n2×2 SMatrix{2, 2, Int64, 4} with indices SOneTo(2)×SOneTo(2):\n 2  4\n 1  8\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#Base.similar-Tuple{SA} where SA<:StaticArray","page":"API","title":"Base.similar","text":"similar(static_array)\nsimilar(static_array, T)\nsimilar(array, ::Size)\nsimilar(array, T, ::Size)\n\nConstructs and returns a mutable but statically-sized array (i.e. a StaticArray). If the input array is not a StaticArray, then the Size is required to determine the output size (or else a dynamically sized array will be returned).\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#LinearAlgebra.qr-Tuple{StaticArray{Tuple{N, M}, T, 2} where {N, M, T}}","page":"API","title":"LinearAlgebra.qr","text":"qr(A::StaticMatrix,\n   pivot::Union{Val{true}, Val{false}, LinearAlgebra.PivotingStrategy} = Val(false))\n\nCompute the QR factorization of A. The factors can be obtained by iteration:\n\njulia> A = @SMatrix rand(3,4);\n\njulia> Q, R = qr(A);\n\njulia> Q * R ≈ A\ntrue\n\nor by using getfield:\n\njulia> F = qr(A);\n\njulia> F.Q * F.R ≈ A\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays._construct_similar-Union{Tuple{ET}, Tuple{L}, Tuple{Any, Size, Tuple{ET, Vararg{ET, L}}}} where {L, ET}","page":"API","title":"StaticArrays._construct_similar","text":"_construct_similar(a, ::Size, elements::NTuple)\n\nConstruct a static array of similar type to a with the given elements.\n\nWhen a is an instance or a concrete type the element type eltype(a) is used. However, when a is a UnionAll type such as SMatrix{2,2}, the promoted type of elements is used instead.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays._lind-Union{Tuple{tA}, Tuple{sa}, Tuple{Symbol, Type{StaticArrays.TSize{sa, tA}}, Int64, Int64}} where {sa, tA}","page":"API","title":"StaticArrays._lind","text":"Obtain an expression for the linear index of var[k,j], taking transposes into account\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays._muladd_expr-Tuple{Array{Expr, N} where N, Array{Expr, N} where N, Type{var\"#s24\"} where var\"#s24\"<:StaticArrays.AlphaBeta}","page":"API","title":"StaticArrays._muladd_expr","text":"Combine left and right sides of an assignment expression, short-cutting         lhs = α * rhs + β * lhs,     element-wise. If α = 1, the multiplication by α is removed. If β = 0, the second rhs term is removed.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays._size-Tuple{Any}","page":"API","title":"StaticArrays._size","text":"Return either the statically known Size() or runtime size()\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.arithmetic_closure-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"StaticArrays.arithmetic_closure","text":"arithmetic_closure(T)\n\nReturn the type which values of type T will promote to under a combination of the arithmetic operations +, -, * and /.\n\njulia> import StaticArrays.arithmetic_closure\n\njulia> arithmetic_closure(Bool)\nFloat64\n\njulia> arithmetic_closure(Int32)\nFloat64\n\njulia> arithmetic_closure(BigFloat)\nBigFloat\n\njulia> arithmetic_closure(BigInt)\nBigFloat\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.check_dims-Union{Tuple{sc}, Tuple{sb}, Tuple{sa}, Tuple{Size{sc}, Size{sa}, Size{sb}}} where {sa, sb, sc}","page":"API","title":"StaticArrays.check_dims","text":"Validate the dimensions of a matrix multiplication, including matrix-vector products\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.construct_type-Union{Tuple{SA}, Tuple{Type{SA}, Any}} where SA<:StaticArray","page":"API","title":"StaticArrays.construct_type","text":"SA′ = construct_type(::Type{SA}, x) where {SA<:StaticArray}\n\nPick a proper constructor SA′ based on x if SA(x)/SA(x...) has no specific definition. The default returned SA′ is SA itself for user defined StaticArrays. This differs from  similar_type() in that SA′ should always be a subtype of SA.\n\nnote: Note\nTo distinguish SA(x...) and SA(x::Tuple), the former calls  construct_type(SA, StaticArrays.Args(x)) instead of construct_type(SA, x).\n\nnote: Note\nPlease make sure SA'(x) has a specific definition if the default behavior is overloaded.  Otherwise construction might fall into infinite recursion.\n\n\n\nThe adaption rules for official StaticArrays could be summarized as:\n\nSA <: FieldArray: eltype adaptable\n\nFieldArrays are always static-sized. We only derive SA′'s eltype using type promotion if needed.\n\nSA <: Union{SArray, MArray, SHermitianCompact, SizedArray}: size/eltype adaptable\n\nSA(x::Tuple)\n\nIf SA is fully static-sized, then we first try to fill SA with x's elements.  If failed and length(SA) == 1, then we try to fill SA with x itself.\n\nIf SA is not fully static-sized, then we always try to fill SA with x's elements,  and the constructor's Size is derived based on:\n\nIf SA <: StaticVector, then we use length(x) as the output Length \nIf SA <: StaticMatrix{M}, then we use (M, N) (N = length(x) ÷ M) as the output Size\nIf SA <: StaticMatrix{M,M} where M, then we use (N, N) (N = sqrt(length(x)) as the output Size.\n\nSA(x...)\n\nSimilar to Tuple, but we never fill SA with x itself.\n\nSA(x::StaticArray)\n\nWe treat x as Tuple whenever possible. If failed, then try to inherit x's Size.\n\nSA(x::AbstractArray)\n\nx is used to provide eltype. Thus SA must be static sized.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.deleteat-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}","page":"API","title":"StaticArrays.deleteat","text":"deleteat(vec::StaticVector, index::Integer)\n\nReturn a new vector with the item at the given index removed.\n\nExamples\n\njulia> deleteat(@SVector[6, 5, 4, 3, 2, 1], 2)\n5-element SVector{5, Int64} with indices SOneTo(5):\n 6\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.dimmatch","page":"API","title":"StaticArrays.dimmatch","text":"dimmatch(x::StaticDimension, y::StaticDimension)\n\nReturn whether dimensions x and y match at compile time, that is:\n\nif x and y are both Ints, check that they are equal\nif x or y are Dynamic(), return true\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#StaticArrays.gen_by_access","page":"API","title":"StaticArrays.gen_by_access","text":"gen_by_access(expr_gen, a::Type{<:AbstractArray}, asym = :wrapped_a)\n\nStatically generate outer code for fully unrolled multiplication loops. Returned code does wrapper-specific tests (for example if a symmetric matrix view is U or L) and the body of the if expression is then generated by function expr_gen. The function expr_gen receives access pattern description symbol as its argument and this symbol is then consumed by uplo_access to generate the right code for matrix element access.\n\nThe name of the matrix to test is indicated by asym.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#StaticArrays.gen_by_access-Tuple{Any, Type{var\"#s24\"} where var\"#s24\"<:(StaticArray{Tuple{N, M}, T, 2} where {N, M, T}), Type}","page":"API","title":"StaticArrays.gen_by_access","text":"gen_by_access(expr_gen, a::Type{<:AbstractArray}, b::Type{<:AbstractArray})\n\nSimilar to genbyaccess with only one type argument. The difference is that tests for both arrays of type a and b are generated and expr_gen receives two access arguments, first for matrix a and the second for matrix b.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.insert-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any, Any}","page":"API","title":"StaticArrays.insert","text":"insert(vec::StaticVector, index::Integer, item)\n\nReturn a new vector with item inserted into vec at the given index.\n\nExamples\n\njulia> insert(@SVector[6, 5, 4, 2, 1], 4, 3)\n6-element SVector{6, Int64} with indices SOneTo(6):\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.mul_result_structure-Tuple{Any, Any}","page":"API","title":"StaticArrays.mul_result_structure","text":"mul_result_structure(a::Type, b::Type)\n\nGet a structure wrapper that should be applied to the result of multiplication of matrices of given types (a*b). \n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.multiplied_dimension-Tuple{Type{var\"#s23\"} where var\"#s23\"<:(Union{LinearAlgebra.Adjoint{T, var\"#s5\"} where var\"#s5\"<:Union{StaticArray{Tuple{var\"#s2\"}, T, 1} where var\"#s2\", StaticArray{Tuple{var\"#s3\", var\"#s4\"}, T, 2} where {var\"#s3\", var\"#s4\"}}, LinearAlgebra.Diagonal{T, var\"#s12\"} where var\"#s12\"<:(StaticArray{Tuple{var\"#s13\"}, T, 1} where var\"#s13\"), LinearAlgebra.Hermitian{T, var\"#s9\"} where var\"#s9\"<:(StaticArray{Tuple{var\"#s10\", var\"#s11\"}, T, 2} where {var\"#s10\", var\"#s11\"}), LinearAlgebra.LowerTriangular{T, var\"#s17\"} where var\"#s17\"<:(StaticArray{Tuple{var\"#s18\", var\"#s19\"}, T, 2} where {var\"#s18\", var\"#s19\"}), LinearAlgebra.Symmetric{T, var\"#s6\"} where var\"#s6\"<:(StaticArray{Tuple{var\"#s7\", var\"#s8\"}, T, 2} where {var\"#s7\", var\"#s8\"}), LinearAlgebra.Transpose{T, var\"#s4\"} where var\"#s4\"<:Union{StaticArray{Tuple{var\"#s2\"}, T, 1} where var\"#s2\", StaticArray{Tuple{var\"#s3\", var\"#s4\"}, T, 2} where {var\"#s3\", var\"#s4\"}}, LinearAlgebra.UnitLowerTriangular{T, var\"#s23\"} where var\"#s23\"<:(StaticArray{Tuple{var\"#s24\", var\"#s25\"}, T, 2} where {var\"#s24\", var\"#s25\"}), LinearAlgebra.UnitUpperTriangular{T, var\"#s20\"} where var\"#s20\"<:(StaticArray{Tuple{var\"#s21\", var\"#s22\"}, T, 2} where {var\"#s21\", var\"#s22\"}), LinearAlgebra.UpperTriangular{T, var\"#s14\"} where var\"#s14\"<:(StaticArray{Tuple{var\"#s15\", var\"#s16\"}, T, 2} where {var\"#s15\", var\"#s16\"}), StaticArray{Tuple{var\"#s25\"}, T, 1} where var\"#s25\", StaticArray{Tuple{var\"#s1\", var\"#s3\"}, T, 2} where {var\"#s1\", var\"#s3\"}} where T), Type{var\"#s22\"} where var\"#s22\"<:(Union{LinearAlgebra.Adjoint{T, var\"#s5\"} where var\"#s5\"<:Union{StaticArray{Tuple{var\"#s2\"}, T, 1} where var\"#s2\", StaticArray{Tuple{var\"#s3\", var\"#s4\"}, T, 2} where {var\"#s3\", var\"#s4\"}}, LinearAlgebra.Diagonal{T, var\"#s12\"} where var\"#s12\"<:(StaticArray{Tuple{var\"#s13\"}, T, 1} where var\"#s13\"), LinearAlgebra.Hermitian{T, var\"#s9\"} where var\"#s9\"<:(StaticArray{Tuple{var\"#s10\", var\"#s11\"}, T, 2} where {var\"#s10\", var\"#s11\"}), LinearAlgebra.LowerTriangular{T, var\"#s17\"} where var\"#s17\"<:(StaticArray{Tuple{var\"#s18\", var\"#s19\"}, T, 2} where {var\"#s18\", var\"#s19\"}), LinearAlgebra.Symmetric{T, var\"#s6\"} where var\"#s6\"<:(StaticArray{Tuple{var\"#s7\", var\"#s8\"}, T, 2} where {var\"#s7\", var\"#s8\"}), LinearAlgebra.Transpose{T, var\"#s4\"} where var\"#s4\"<:Union{StaticArray{Tuple{var\"#s2\"}, T, 1} where var\"#s2\", StaticArray{Tuple{var\"#s3\", var\"#s4\"}, T, 2} where {var\"#s3\", var\"#s4\"}}, LinearAlgebra.UnitLowerTriangular{T, var\"#s23\"} where var\"#s23\"<:(StaticArray{Tuple{var\"#s24\", var\"#s25\"}, T, 2} where {var\"#s24\", var\"#s25\"}), LinearAlgebra.UnitUpperTriangular{T, var\"#s20\"} where var\"#s20\"<:(StaticArray{Tuple{var\"#s21\", var\"#s22\"}, T, 2} where {var\"#s21\", var\"#s22\"}), LinearAlgebra.UpperTriangular{T, var\"#s14\"} where var\"#s14\"<:(StaticArray{Tuple{var\"#s15\", var\"#s16\"}, T, 2} where {var\"#s15\", var\"#s16\"}), StaticArray{Tuple{var\"#s25\"}, T, 1} where var\"#s25\", StaticArray{Tuple{var\"#s1\", var\"#s3\"}, T, 2} where {var\"#s1\", var\"#s3\"}} where T)}","page":"API","title":"StaticArrays.multiplied_dimension","text":"Calculate the product of the dimensions being multiplied. Useful as a heuristic for unrolling.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.pop-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}","page":"API","title":"StaticArrays.pop","text":"pop(vec::StaticVector)\n\nReturn a new vector with the last item in vec removed.\n\nExamples\n\njulia> pop(@SVector[1,2,3])\n2-element SVector{2, Int64} with indices SOneTo(2):\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.popfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}}","page":"API","title":"StaticArrays.popfirst","text":"popfirst(vec::StaticVector)\n\nReturn a new vector with the first item in vec removed.\n\nExamples\n\njulia> popfirst(@SVector[1,2,3])\n2-element SVector{2, Int64} with indices SOneTo(2):\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.push-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}","page":"API","title":"StaticArrays.push","text":"push(vec::StaticVector, item)\n\nReturn a new StaticVector with item inserted on the end of vec.\n\nExamples\n\njulia> push(@SVector[1, 2, 3], 4)\n4-element SVector{4, Int64} with indices SOneTo(4):\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.pushfirst-Tuple{StaticArray{Tuple{N}, T, 1} where {N, T}, Any}","page":"API","title":"StaticArrays.pushfirst","text":"pushfirst(vec::StaticVector, item)\n\nReturn a new StaticVector with item inserted at the beginning of vec.\n\nExamples\n\njulia> pushfirst(@SVector[1, 2, 3, 4], 5)\n5-element SVector{5, Int64} with indices SOneTo(5):\n 5\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.sacollect","page":"API","title":"StaticArrays.sacollect","text":"sacollect(SA, gen)\n\nConstruct a statically-sized vector of type SA.from a generator gen. SA needs to have a size parameter since the length of vec is unknown to the compiler. SA can optionally specify the element type as well.\n\nExample:\n\nsacollect(SVector{3, Int}, 2i+1 for i in 1:3)\nsacollect(SMatrix{2, 3}, i+j for i in 1:2, j in 1:3)\nsacollect(SArray{2, 3}, i+j for i in 1:2, j in 1:3)\n\nThis creates the same statically-sized vector as if the generator were collected in an array, but is more efficient since no array is allocated.\n\nEquivalent:\n\nSVector{3, Int}([2i+1 for i in 1:3])\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#StaticArrays.same_size-Tuple","page":"API","title":"StaticArrays.same_size","text":"Returns the common Size of the inputs (or else throws a DimensionMismatch)\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.sizematch-Union{Tuple{S2}, Tuple{S1}, Tuple{Size{S1}, Size{S2}}} where {S1, S2}","page":"API","title":"StaticArrays.sizematch","text":"sizematch(::Size, ::Size)\nsizematch(::Tuple, ::Tuple)\n\nDetermine whether two sizes match, in the sense that they have the same number of dimensions, and their dimensions match as determined by dimmatch.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.sizematch-Union{Tuple{S}, Tuple{Size{S}, StaticArray}} where S","page":"API","title":"StaticArrays.sizematch","text":"sizematch(::Size, A::AbstractArray)\n\nDetermine whether array A matches the given size. If A is a StaticArray, the check is performed at compile time, otherwise, the check is performed at runtime.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.uplo_access-NTuple{5, Any}","page":"API","title":"StaticArrays.uplo_access","text":"uplo_access(sa, asym, k, j, uplo)\n\nGenerate code for matrix element access, for a matrix of size sa locally referred to as asym in the context where the result will be used. Both indices k and j need to be statically known for this function to work. uplo is the access pattern mode generated by the gen_by_access function.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#StaticArrays.@MArray-Tuple{Any}","page":"API","title":"StaticArrays.@MArray","text":"@MArray [a b; c d]\n@MArray [[a, b];[c, d]]\n@MArray [i+j for i in 1:2, j in 1:2]\n@MArray ones(2, 2, 2)\n\nA convenience macro to construct MArray with arbitrary dimension. See @SArray for detailed features.\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#StaticArrays.@MMatrix-Tuple{Any}","page":"API","title":"StaticArrays.@MMatrix","text":"@MMatrix [a b c d]\n@MMatrix [[a, b];[c, d]]\n@MMatrix [i+j for i in 1:2, j in 1:2]\n@MMatrix ones(2, 2)\n\nA convenience macro to construct MMatrix. See @SArray for detailed features.\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#StaticArrays.@MVector-Tuple{Any}","page":"API","title":"StaticArrays.@MVector","text":"@MVector [a, b, c, d]\n@MVector [i for i in 1:2]\n@MVector ones(2)\n\nA convenience macro to construct MVector. See @SArray for detailed features.\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#StaticArrays.@SArray-Tuple{Any}","page":"API","title":"StaticArrays.@SArray","text":"@SArray [a b; c d]\n@SArray [[a, b];[c, d]]\n@SArray [i+j for i in 1:2, j in 1:2]\n@SArray ones(2, 2, 2)\n\nA convenience macro to construct SArray with arbitrary dimension. It supports:\n\n(typed) array literals.\n\nnote: Note\nEvery argument inside the square brackets is treated as a scalar during expansion. Thus @SArray[a; b] always forms a SVector{2} and @SArray [a b; c] always throws an error.\n\ncomprehensions\n\nnote: Note\nThe range of a comprehension is evaluated at global scope by the macro, and must be made of combinations of literal values, functions, or global variables.\n\ninitialization functions\n\nnote: Note\nOnly support zeros(), ones(), fill(), rand(), randn(), and randexp()\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#StaticArrays.@SMatrix-Tuple{Any}","page":"API","title":"StaticArrays.@SMatrix","text":"@SMatrix [a b c d]\n@SMatrix [[a, b];[c, d]]\n@SMatrix [i+j for i in 1:2, j in 1:2]\n@SMatrix ones(2, 2)\n\nA convenience macro to construct SMatrix. See @SArray for detailed features.\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#StaticArrays.@SVector-Tuple{Any}","page":"API","title":"StaticArrays.@SVector","text":"@SVector [a, b, c, d]\n@SVector [i for i in 1:2]\n@SVector ones(2)\n\nA convenience macro to construct SVector. See @SArray for detailed features.\n\n\n\n\n\n","category":"macro"},{"location":"pages/api/#StaticArraysCore.Dynamic","page":"API","title":"StaticArraysCore.Dynamic","text":"Dynamic()\n\nUsed to signify that a dimension of an array is not known statically.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.FieldArray","page":"API","title":"StaticArraysCore.FieldArray","text":"abstract FieldArray{N, T, D} <: StaticArray{N, T, D}\n\nInheriting from this type will make it easy to create your own rank-D tensor types. A FieldArray will automatically define getindex and setindex! appropriately. An immutable FieldArray will be as performant as an SArray of similar length and element type, while a mutable FieldArray will behave similarly to an MArray.\n\nNote that you must define the fields of any FieldArray subtype in column major order. If you want to use an alternative ordering you will need to pay special attention in providing your own definitions of getindex, setindex! and tuple conversion.\n\nIf you define a FieldArray which is parametric on the element type you should consider defining similar_type as in the FieldVector example.\n\nExample\n\nstruct Stiffness <: FieldArray{Tuple{2,2,2,2}, Float64, 4}\n    xxxx::Float64\n    yxxx::Float64\n    xyxx::Float64\n    yyxx::Float64\n    xxyx::Float64\n    yxyx::Float64\n    xyyx::Float64\n    yyyx::Float64\n    xxxy::Float64\n    yxxy::Float64\n    xyxy::Float64\n    yyxy::Float64\n    xxyy::Float64\n    yxyy::Float64\n    xyyy::Float64\n    yyyy::Float64\nend\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.FieldMatrix","page":"API","title":"StaticArraysCore.FieldMatrix","text":"abstract FieldMatrix{N1, N2, T} <: FieldArray{Tuple{N1, N2}, 2}\n\nInheriting from this type will make it easy to create your own rank-two tensor types. A FieldMatrix will automatically define getindex and setindex! appropriately. An immutable FieldMatrix will be as performant as an SMatrix of similar length and element type, while a mutable FieldMatrix will behave similarly to an MMatrix.\n\nNote that the fields of any subtype of FieldMatrix must be defined in column major order unless you are willing to implement your own getindex.\n\nIf you define a FieldMatrix which is parametric on the element type you should consider defining similar_type as in the FieldVector example.\n\nExample\n\nstruct Stress <: FieldMatrix{3, 3, Float64}\n    xx::Float64\n    yx::Float64\n    zx::Float64\n    xy::Float64\n    yy::Float64\n    zy::Float64\n    xz::Float64\n    yz::Float64\n    zz::Float64\nend\n\nNote that the fields of any subtype of FieldMatrix must be defined in column major order.  This means that formatting of constructors for literal FieldMatrix can be confusing. For example\n\nsigma = Stress(1.0, 2.0, 3.0,\n               4.0, 5.0, 6.0,\n               7.0, 8.0, 9.0)\n\n3×3 Stress:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0\n\nwill give you the transpose of what the multi-argument formatting suggests. For clarity, you may consider using the alternative\n\nsigma = Stress(SA[1.0 2.0 3.0;\n                  4.0 5.0 6.0;\n                  7.0 8.0 9.0])\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.FieldVector","page":"API","title":"StaticArraysCore.FieldVector","text":"abstract FieldVector{N, T} <: FieldArray{Tuple{N}, 1}\n\nInheriting from this type will make it easy to create your own vector types. A FieldVector will automatically define getindex and setindex! appropriately. An immutable FieldVector will be as performant as an SVector of similar length and element type, while a mutable FieldVector will behave similarly to an MVector.\n\nIf you define a FieldVector which is parametric on the element type you should consider defining similar_type to preserve your array type through array operations as in the example below.\n\nExample\n\nstruct Vec3D{T} <: FieldVector{3, T}\n    x::T\n    y::T\n    z::T\nend\n\nStaticArrays.similar_type(::Type{<:Vec3D}, ::Type{T}, s::Size{(3,)}) where {T} = Vec3D{T}\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.MArray","page":"API","title":"StaticArraysCore.MArray","text":"MArray{S, T, N, L}(undef)\nMArray{S, T, N, L}(x::NTuple{L})\nMArray{S, T, N, L}(x1, x2, x3, ...)\n\nConstruct a statically-sized, mutable array MArray. The data may optionally be provided upon construction and can be mutated later. The S parameter is a Tuple-type specifying the dimensions, or size, of the array - such as Tuple{3,4,5} for a 3×4×5-sized array. The N parameter is the dimension of the array; the L parameter is the length of the array and is always equal to prod(S). Constructors may drop the L, N and T parameters if they are inferrable from the input (e.g. L is always inferrable from S).\n\nMArray{S}(a::Array)\n\nConstruct a statically-sized, mutable array of dimensions S (expressed as a Tuple{...}) using the data from a. The S parameter is mandatory since the size of a is unknown to the compiler (the element type may optionally also be specified).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.MMatrix","page":"API","title":"StaticArraysCore.MMatrix","text":"MMatrix{S1, S2, T, L}(undef)\nMMatrix{S1, S2, T, L}(x::NTuple{L, T})\nMMatrix{S1, S2, T, L}(x1, x2, x3, ...)\n\nConstruct a statically-sized, mutable matrix MMatrix. The data may optionally be provided upon construction and can be mutated later. The L parameter is the length of the array and is always equal to S1 * S2. Constructors may drop the L, T and even S2 parameters if they are inferrable from the input (e.g. L is always inferrable from S1 and S2).\n\nMMatrix{S1, S2}(mat::Matrix)\n\nConstruct a statically-sized, mutable matrix of dimensions S1 × S2 using the data from mat. The parameters S1 and S2 are mandatory since the size of mat is unknown to the compiler (the element type may optionally also be specified).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.MVector","page":"API","title":"StaticArraysCore.MVector","text":"MVector{S,T}(undef)\nMVector{S,T}(x::NTuple{S, T})\nMVector{S,T}(x1, x2, x3, ...)\n\nConstruct a statically-sized, mutable vector MVector. Data may optionally be provided upon construction, and can be mutated later. Constructors may drop the T and S parameters if they are inferrable from the input (e.g. MVector(1,2,3) constructs an MVector{3, Int}).\n\nMVector{S}(vec::Vector)\n\nConstruct a statically-sized, mutable vector of length S using the data from vec. The parameter S is mandatory since the length of vec is unknown to the compiler (the element type may optionally also be specified).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.SArray","page":"API","title":"StaticArraysCore.SArray","text":"SArray{S, T, N, L}(x::NTuple{L})\nSArray{S, T, N, L}(x1, x2, x3, ...)\n\nConstruct a statically-sized array SArray. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The S parameter is a Tuple-type specifying the dimensions, or size, of the array - such as Tuple{3,4,5} for a 3×4×5-sized array. The N parameter is the dimension of the array; the L parameter is the length of the array and is always equal to prod(S). Constructors may drop the L, N and T parameters if they are inferrable from the input (e.g. L is always inferrable from S).\n\nSArray{S}(a::Array)\n\nConstruct a statically-sized array of dimensions S (expressed as a Tuple{...}) using the data from a. The S parameter is mandatory since the size of a is unknown to the compiler (the element type may optionally also be specified).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.SMatrix","page":"API","title":"StaticArraysCore.SMatrix","text":"SMatrix{S1, S2, T, L}(x::NTuple{L, T})\nSMatrix{S1, S2, T, L}(x1, x2, x3, ...)\n\nConstruct a statically-sized matrix SMatrix. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. The L parameter is the length of the array and is always equal to S1 * S2. Constructors may drop the L, T and even S2 parameters if they are inferrable from the input (e.g. L is always inferrable from S1 and S2).\n\nSMatrix{S1, S2}(mat::Matrix)\n\nConstruct a statically-sized matrix of dimensions S1 × S2 using the data from mat. The parameters S1 and S2 are mandatory since the size of mat is unknown to the compiler (the element type may optionally also be specified).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.SVector","page":"API","title":"StaticArraysCore.SVector","text":"SVector{S, T}(x::NTuple{S, T})\nSVector{S, T}(x1, x2, x3, ...)\n\nConstruct a statically-sized vector SVector. Since this type is immutable, the data must be provided upon construction and cannot be mutated later. Constructors may drop the T and S parameters if they are inferrable from the input (e.g. SVector(1,2,3) constructs an SVector{3, Int}).\n\nSVector{S}(vec::Vector)\n\nConstruct a statically-sized vector of length S using the data from vec. The parameter S is mandatory since the length of vec is unknown to the compiler (the element type may optionally also be specified).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.Size","page":"API","title":"StaticArraysCore.Size","text":"Size(dims::Int...)\n\nSize is used extensively throughout the StaticArrays API to describe compile-time knowledge of the size of an array. The dimensions are stored as a type parameter and are statically propagated by the compiler, resulting in efficient, type-inferrable code. For example, to create a static matrix of zeros, use A = zeros(SMatrix{3,3}). The static size of A can be obtained by Size(A). (rather than size(zeros(3,3)), which returns Base.Tuple{2,Int}).\n\nNote that if dimensions are not known statically (e.g., for standard Arrays), Dynamic() should be used instead of an Int.\n\nSize(a::AbstractArray)\nSize(::Type{T<:AbstractArray})\n\nThe Size constructor can be used to extract static dimension information from a given array. For example:\n\njulia> Size(zeros(SMatrix{3, 4}))\nSize(3, 4)\n\njulia> Size(zeros(3, 4))\nSize(StaticArrays.Dynamic(), StaticArrays.Dynamic())\n\nThis has multiple uses, including \"trait\"-based dispatch on the size of a statically-sized array. For example:\n\ndet(x::StaticMatrix) = _det(Size(x), x)\n_det(::Size{(1,1)}, x::StaticMatrix) = x[1,1]\n_det(::Size{(2,2)}, x::StaticMatrix) = x[1,1]*x[2,2] - x[1,2]*x[2,1]\n# and other definitions as necessary\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.SizedArray","page":"API","title":"StaticArraysCore.SizedArray","text":"SizedArray{Tuple{dims...}}(array)\n\nWraps an AbstractArray with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (length) match, but the array may be reshaped.\n\nThe aliases SizedVector{N} and SizedMatrix{N,M} are provided as more convenient names for one and two dimensional SizedArrays. For example, to wrap a 2x3 array a in a SizedArray, use SizedMatrix{2,3}(a).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.StaticArray","page":"API","title":"StaticArraysCore.StaticArray","text":"abstract type StaticArray{S, T, N} <: AbstractArray{T, N} end\nStaticScalar{T}     = StaticArray{Tuple{}, T, 0}\nStaticVector{N,T}   = StaticArray{Tuple{N}, T, 1}\nStaticMatrix{N,M,T} = StaticArray{Tuple{N,M}, T, 2}\n\nStaticArrays are Julia arrays with fixed, known size.\n\nDev docs\n\nThey must define the following methods:\n\nConstructors that accept a flat tuple of data.\ngetindex() with an integer (linear indexing) (preferably @inline with @boundscheck).\nTuple(), returning the data in a flat Tuple.\n\nIt may be useful to implement:\n\nsimilar_type(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize}), returning a type (or type constructor) that accepts a flat tuple of data.\n\nFor mutable containers you may also need to define the following:\n\nsetindex! for a single element (linear indexing).\nsimilar(::Type{MyStaticArray}, ::Type{NewElType}, ::Size{NewSize}).\nIn some cases, a zero-parameter constructor, MyStaticArray{...}() for unintialized data is assumed to exist.\n\n(see also SVector, SMatrix, SArray, MVector, MMatrix, MArray, SizedArray, FieldVector, FieldMatrix and FieldArray)\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#StaticArraysCore.similar_type","page":"API","title":"StaticArraysCore.similar_type","text":"similar_type(static_array)\nsimilar_type(static_array, T)\nsimilar_type(array, ::Size)\nsimilar_type(array, T, ::Size)\n\nReturns a constructor for a statically-sized array similar to the input array (or type) static_array/array, optionally with different element type T or size Size. If the input array is not a StaticArray then the Size is mandatory.\n\nThis differs from similar() in that the resulting array type may not be mutable (or define setindex!()), and therefore the returned type may need to be constructed with its data.\n\nNote that the (optional) size must be specified as a static Size object (so the compiler can infer the result statically).\n\nNew types should define the signature similar_type(::Type{A},::Type{T},::Size{S}) where {A<:MyType,T,S} if they wish to overload the default behavior.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#StaticArraysCore.size_to_tuple-Union{Tuple{Type{T}}, Tuple{T}} where T<:Tuple","page":"API","title":"StaticArraysCore.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"method"},{"location":"pages/quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"pages/quickstart/","page":"Quick Start","title":"Quick Start","text":"Pkg.add(\"StaticArrays\")  # or Pkg.clone(\"https://github.com/JuliaArrays/StaticArrays.jl\")\nusing StaticArrays\nusing LinearAlgebra\n\n# Use the convenience constructor type `SA` to create vectors and matrices\nSA[1, 2, 3]     isa SVector{3,Int}\nSA_F64[1, 2, 3] isa SVector{3,Float64}\nSA_F32[1, 2, 3] isa SVector{3,Float32}\nSA[1 2; 3 4]     isa SMatrix{2,2,Int}\nSA_F64[1 2; 3 4] isa SMatrix{2,2,Float64}\n\n# Create an SVector using various forms, using constructors, functions or macros\nv1 = SVector(1, 2, 3)\nv1.data === (1, 2, 3) # SVector uses a tuple for internal storage\nv2 = SVector{3,Float64}(1, 2, 3) # length 3, eltype Float64\nv3 = @SVector [1, 2, 3]\nv4 = @SVector [i^2 for i = 1:10] # arbitrary comprehensions (range is evaluated at global scope)\nv5 = zeros(SVector{3}) # defaults to Float64\nv6 = @SVector zeros(3)\nv7 = SVector{3}([1, 2, 3]) # Array conversions must specify size\n\n# Can get size() from instance or type\nsize(v1) == (3,)\nsize(typeof(v1)) == (3,)\n\n# Similar constructor syntax for matrices\nm1 = SMatrix{2,2}(1, 2, 3, 4) # flat, column-major storage, equal to m2:\nm2 = @SMatrix [ 1  3 ;\n                2  4 ]\nm3 = SMatrix{3,3}(1I)\nm4 = @SMatrix randn(4,4)\nm5 = SMatrix{2,2}([1 3 ; 2 4]) # Array conversions must specify size\n\n# Higher-dimensional support\na = @SArray randn(2, 2, 2, 2, 2, 2)\n\n# Supports all the common operations of AbstractArray\nv7 = v1 + v2\nv8 = sin.(v3)\nv3 == m3 * v3 # recall that m3 = SMatrix{3,3}(1I)\n# map, reduce, broadcast, map!, broadcast!, etc...\n\n# Indexing can also be done using static arrays of integers\nv1[1] === 1\nv1[SVector(3,2,1)] === @SVector [3, 2, 1]\nv1[:] === v1\ntypeof(v1[[1,2,3]]) <: Vector # Can't determine size from the type of [1,2,3]\n\n# For geometric and computer graphics applications in dimensions 1 to 4, the\n# conventional dimension names x,y,z,w can be used to access elements of the\n# vector:\n\nu = SA[1,2,3,4]\n\nu.x === u[1]\nu.y === u[2]\nu.z === u[3]\nu.w === u[4]\n\n# The x,y,z and w properties also work to set values in those dimensions:\nm6 = MVector(1,2)\nm6.x = 10\n# The following is now true\nm6[1] === 10\n\n# Is (partially) hooked into BLAS, LAPACK, etc:\nrand(MMatrix{20,20}) * rand(MMatrix{20,20}) # large matrices can use BLAS\neigen(m3) # eigen(), etc uses specialized algorithms up to 3×3, or else LAPACK\n\n# Static arrays stay statically sized, even when used by Base functions, etc:\ntypeof(eigen(m3)) == Eigen{Float64,Float64,SArray{Tuple{3,3},Float64,2,9},SArray{Tuple{3},Float64,1,3}}\n\n# similar() returns a mutable container, while similar_type() returns a constructor:\ntypeof(similar(m3)) == MArray{Tuple{3,3},Int64,2,9} # (final parameter is length = 9)\nsimilar_type(m3) == SArray{Tuple{3,3},Int64,2,9}\n\n# The Size trait is a compile-time constant representing the size\nSize(m3) === Size(3,3)\n\n# A standard Array can be wrapped into a SizedArray\nm4 = SizedMatrix{3,3}(rand(3,3))\ninv(m4) # Take advantage of specialized fast methods\n\n# reshape() uses Size() or types to specify size:\nreshape([1,2,3,4], Size(2,2)) == @SMatrix [ 1  3 ;\n                                            2  4 ]\ntypeof(reshape([1,2,3,4], Size(2,2))) === SizedArray{Tuple{2, 2},Int64,2,1}\n","category":"page"},{"location":"#Static-Arrays","page":"Home","title":"Static Arrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Statically sized arrays for Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"StaticArrays provides a framework for implementing statically sized arrays in Julia, using the abstract type StaticArray{Size,T,N} <: AbstractArray{T,N}. Subtypes of StaticArray will provide fast implementations of common array and linear algebra operations. Note that here \"statically sized\" means that the size can be determined from the type, and \"static\" does not necessarily imply immutable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package also provides some concrete static array types: SVector, SMatrix and SArray, which may be used as-is (or else embedded in your own type). Mutable versions MVector, MMatrix and MArray are also exported, as well as SizedArray for annotating standard Arrays with static size information. Further, the abstract FieldVector can be used to make fast static vectors out of any uniform Julia \"struct\".","category":"page"}]
}
